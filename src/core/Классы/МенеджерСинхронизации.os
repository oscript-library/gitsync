///////////////////////////////////////////////////////////////////////////////////////////////
//
// Модуль основан на проекте v83unpack (https://github.com/xDrivenDevelopment/v83unpack)
// и является скорее глубоким рефакторингом под 1Script, нежели самостоятельной разработкой.
//
// Использует также утилиту Tool_1CD от awa (http://infostart.ru/public/19633/)
//
///////////////////////////////////////////////////////////////////////////////////////////////

#Использовать tool1cd
#Использовать logos
#Использовать tempfiles
#Использовать v8runner
#Использовать strings
#Использовать 1commands
#Использовать v8unpack
#Использовать gitrunner
#Использовать fs

Перем Лог;
Перем мФайлПрограммыРаспаковки;
Перем мАвторизацияВХранилищеСредствами1С;
Перем ЭтоWindows;
Перем УдалятьВременныеФайлы;
Перем КоличествоЦикловОжиданияЛицензииПоУмолчанию;

Перем РабочийКаталогСохр;
Перем ГитРепозиторийСохр;
// Определяем мин количество коммитов между разницей версии уже в git и в хранилище
// для случаев, когда пересоздали хранилище и в гите находится версия 1234, а в хранилище 4,
// тогда вызываем исключение если разница в коммитах больше чем на эту велечину. 
Перем МинимальнаяРазницаМеждуКоммитамиНовогоХранилища;

///////////////////////////////////////////////////////////////////////////////////////////////
// ПРОГРАММНЫЙ ИНТЕРФЕЙС

Перем ДоменПочтыДляGitПоУмолчанию Экспорт;
Перем ВерсияПлатформы Экспорт;
Перем ПереименовыватьФайлМодуляОбычнойФормы Экспорт;
Перем ТолькоИзменения Экспорт;
Перем ИспользоватьTool1CD Экспорт; 

// Выполняет выгрузку конфигурации в файлы
// и распределение файлов по каталогам согласно иерархии метаданных.
//
Процедура РазобратьФайлКонфигурации(Знач ФайлКонфигурации, Знач ВыходнойКаталог, Знач Формат) Экспорт

	ОбъектФайл = Новый Файл(ФайлКонфигурации);
	Если Не ОбъектФайл.Существует() Тогда
		ВызватьИсключение СтроковыеФункции.ПодставитьПараметрыВСтроку("Файл конфигурации %1 не найден", ФайлКонфигурации.ПолноеИмя);
	КонецЕсли;

	КаталогПлоскойВыгрузки = ВременныеФайлы.СоздатьКаталог();

	Если Не (Новый Файл(ВыходнойКаталог).Существует()) Тогда
		СоздатьКаталог(ВыходнойКаталог);
	КонецЕсли;

	КаталогВыгрузки = ?(ТолькоИзменения, ВыходнойКаталог, КаталогПлоскойВыгрузки);
	Попытка
		ВыгрузитьМодулиКонфигурации(ФайлКонфигурации, КаталогВыгрузки, Формат);
		Если НЕ ТолькоИзменения Тогда
			РазложитьМодули1СПоПапкамСогласноИерархииМетаданных(КаталогПлоскойВыгрузки, ВыходнойКаталог, Формат);
		Иначе
			МассивФайлов = НайтиФайлы(КаталогВыгрузки, "*.bin", Истина);
			Для каждого Файл из МассивФайлов Цикл
				Если Нрег(Файл.Имя) = "form.bin" Тогда
					КаталогФормы = ОбъединитьПути(Файл.Путь, Файл.ИмяБезРасширения);
					СоздатьКаталог(КаталогФормы);
					ФС.ОбеспечитьПустойКаталог(КаталогФормы);
					РаспаковатьКонтейнерМетаданных(Файл.ПолноеИмя, КаталогФормы);
				КонецЕсли;
			КонецЦикла;

			Если Новый Файл(ОбъединитьПути(КаталогВыгрузки, "renames.txt")).Существует() Тогда
				УдалитьВременныеФайлыПриНеобходимости(ОбъединитьПути(КаталогВыгрузки, "renames.txt"));
			КонецЕсли;

		КонецЕсли;
	Исключение
		УдалитьВременныеФайлыПриНеобходимости(КаталогПлоскойВыгрузки);
		ВызватьИсключение;
	КонецПопытки;

	УдалитьВременныеФайлыПриНеобходимости(КаталогПлоскойВыгрузки);

КонецПроцедуры

// Выполняет штатную выгрузку конфигурации в файлы (средствами платформы 8.3)
//
Процедура ВыгрузитьМодулиКонфигурации(Знач ФайлКонфигурации, Знач КаталогПлоскойВыгрузки, Знач Формат) Экспорт

	Конфигуратор = ПолучитьМенеджерКонфигуратора();
	Если ВерсияПлатформы <> Неопределено Тогда
		Конфигуратор.ИспользоватьВерсиюПлатформы(ВерсияПлатформы);
	Иначе
		Конфигуратор.ИспользоватьВерсиюПлатформы("8.3");
	КонецЕсли;

	ЛогКонфигуратора = Логирование.ПолучитьЛог("oscript.lib.v8runner");
	ЛогКонфигуратора.УстановитьУровень(Лог.Уровень());
	КоличествоЦикловОжиданияЛицензии = ПолучитьКоличествоЦикловОжиданияЛицензииПоУмолчанию();
	Пока КоличествоЦикловОжиданияЛицензии >= 0 Цикл
		Попытка
			
			Конфигуратор.ЗагрузитьКонфигурациюИзФайла(ФайлКонфигурации, Ложь);
			Прервать;

		Исключение
			
			// проверим текст ошибки, если текст содержит информацию о необходимости конвертировать
			// тогда выполним конвертацию и повторно попытаемся загрузить файл
			ТекстОшибки = ВРег(Конфигуратор.ВыводКоманды());
			Если Найти(ТекстОшибки, Врег("Структура конфигурации несовместима с текущей версией программы")) Тогда
				
				Конфигуратор.СконвертироватьФайлКонфигурации(ФайлКонфигурации);
				Конфигуратор.ЗагрузитьКонфигурациюИзФайла(ФайлКонфигурации, Ложь);
				Прервать;
				
			ИначеЕсли Найти(ТекстОшибки, Врег("Не обнаружено свободной лицензии!")) Тогда
				Лог.Ошибка(ТекстОшибки);
				Лог.Информация("Повторное подключение через 10сек. Осталось попыток: " + КоличествоЦикловОжиданияЛицензии);
				Приостановить(10000);

			Иначе
				
				ВызватьИсключение ТекстОшибки;
				
			КонецЕсли;
			
		КонецПопытки;

		Если ПолучитьКоличествоЦикловОжиданияЛицензииПоУмолчанию() <> 0 Тогда
			КоличествоЦикловОжиданияЛицензии = КоличествоЦикловОжиданияЛицензии - 1;
		КонецЕсли;
		
	КонецЦикла;

	Если Не (Новый Файл(КаталогПлоскойВыгрузки).Существует()) Тогда
		СоздатьКаталог(КаталогПлоскойВыгрузки);
	КонецЕсли;

	Если НЕ ТолькоИзменения Тогда
		МассивФайлов = НайтиФайлы(КаталогПлоскойВыгрузки, ПолучитьМаскуВсеФайлы());
		Если МассивФайлов.Количество() <> 0 Тогда
			ВызватьИсключение "В каталоге <"+КаталогПлоскойВыгрузки+"> не должно быть файлов";
		КонецЕсли;

		ПараметрыЗапуска = Конфигуратор.ПолучитьПараметрыЗапуска();
		ПараметрыЗапуска.Добавить("/Visible");
		ПараметрДампаКонфигурации = СтрШаблон("/DumpConfigToFiles ""%1"" -format %2", КаталогПлоскойВыгрузки, ТРег(Формат));
		ПараметрыЗапуска.Добавить(ПараметрДампаКонфигурации);
	
		ВыполнитьКомандуКонфигуратора(Конфигуратор, ПараметрыЗапуска);

	Иначе
		ТекущийФайлВерсийМетаданных = Новый Файл(ОбъединитьПути(КаталогПлоскойВыгрузки,"ConfigDumpInfo.xml"));
		ТолькоИзмененияЕслиФайлЕсть = ?(ТекущийФайлВерсийМетаданных.Существует(), ТолькоИзменения, Ложь);
		Попытка
			Конфигуратор.ВыгрузитьКонфигурациюВФайлы(КаталогПлоскойВыгрузки, , ТолькоИзмененияЕслиФайлЕсть);
		Исключение
	
			ОписаниеОшибки = ОписаниеОшибки();
			Если ПроверитьОписаниеОшибкиНаКритичность(ОписаниеОшибки) Тогда
				УдалитьВременныеФайлыПриНеобходимости(Конфигуратор.КаталогСборки());
				ВызватьИсключение;
			КонецЕсли;
		КонецПопытки;
	
		УдалитьВременныеФайлыПриНеобходимости(Конфигуратор.КаталогСборки());

	КонецЕсли;
	
КонецПроцедуры

Функция ПолучитьМенеджерКонфигуратора()
	Конфигуратор = Новый УправлениеКонфигуратором;
	Логирование.ПолучитьЛог("oscript.lib.v8runner").УстановитьУровень(Лог.Уровень());
	КаталогСборки = ВременныеФайлы.СоздатьКаталог();
	Конфигуратор.КаталогСборки(КаталогСборки);
	Возврат Конфигуратор;
КонецФункции

Процедура ВыполнитьКомандуКонфигуратора(Знач Конфигуратор, Знач ПараметрыЗапуска)

	Попытка
		Конфигуратор.ВыполнитьКоманду(ПараметрыЗапуска);
	Исключение

		ОписаниеОшибки = ОписаниеОшибки();
		Если ПроверитьОписаниеОшибкиНаКритичность(ОписаниеОшибки) Тогда
			УдалитьВременныеФайлыПриНеобходимости(Конфигуратор.КаталогСборки());
			ВызватьИсключение;
		КонецЕсли;
	КонецПопытки;

	УдалитьВременныеФайлыПриНеобходимости(Конфигуратор.КаталогСборки());

КонецПроцедуры



Функция МассивНеКритическихОшибок()

	Массив = Новый Массив;
	Массив.Добавить("Конфигурация содержит объекты метаданных, длина имен которых превышает 80 символов!");

	Возврат Массив;
КонецФункции

Функция ПроверитьОписаниеОшибкиНаКритичность(Знач ОписаниеОшибки)

	МассивНеКритическихОшибок = МассивНеКритическихОшибок();

	Для Каждого НеКритичнаяОшибка Из МассивНеКритическихОшибок Цикл

		Если СтрНайти(ОписаниеОшибки, НеКритичнаяОшибка) > 0 Тогда 
			Возврат Ложь; 
		КонецЕсли;

	КонецЦикла;
	Возврат Истина;
КонецФункции

// Выполняет перенос файлов из каталога плоской выгрузки в каталог с иерархической структурой метаданных.
//
Процедура РазложитьМодули1СПоПапкамСогласноИерархииМетаданных(Знач КаталогПлоскойВыгрузки, Знач КаталогИерархическойВыгрузки, Знач Формат) Экспорт

	Лог.Информация("Раскладываем модули по папкам согласно иерархии метаданных");

	КэшПереименований = Новый Соответствие;

	УбедитьсяЧтоФайлИлиКаталогСуществует(КаталогПлоскойВыгрузки);

	Если ПустаяСтрока(КаталогИерархическойВыгрузки) Тогда
		ВызватьИсключение "Не задан каталог выгрузки модулей по иерархии";
	КонецЕсли;

	ФайлВыгрузкиКаталог = Новый Файл(КаталогИерархическойВыгрузки);
	Если Не ФайлВыгрузкиКаталог.Существует() Тогда
		СоздатьКаталог(КаталогИерархическойВыгрузки);
		//ЗарегистрироватьВременныйФайл(КаталогИерархическойСтруктурыМодулей); TODO выяснить почему временный?
	КонецЕсли;

	ЗавершитьПроцесс_TGitCache_exe();

	ОчиститьЦелевойКаталогВыгрузки(КаталогИерархическойВыгрузки);

	Переименования = Новый ТаблицаЗначений;
	Переименования.Колонки.Добавить("Источник");
	Переименования.Колонки.Добавить("Приемник");

	НативнаяИерархия = ЭтоНативнаяИерархия(КаталогПлоскойВыгрузки);
	СписокФайлов = НайтиФайлы(КаталогПлоскойВыгрузки, ПолучитьМаскуВсеФайлы(), НативнаяИерархия);
	Лог.Отладка("Найдено файлов выгрузки: "+СписокФайлов.Количество()+" шт.");
	Для Каждого Файл Из СписокФайлов Цикл
		ИмяФайлаДляПереименования = Файл.Имя;
		Если НативнаяИерархия Тогда
			ИмяНовогоФайла = СтрЗаменить(Файл.ПолноеИмя, КаталогПлоскойВыгрузки, "");
			ИмяНовогоФайла = ?(Лев(ИмяНовогоФайла, 1) ="/", Сред(ИмяНовогоФайла, 2), ИмяНовогоФайла);
			ИмяНовогоФайла = ?(Лев(ИмяНовогоФайла, 1) ="\", Сред(ИмяНовогоФайла, 2), ИмяНовогоФайла);
			Если Файл.ЭтоКаталог() Тогда
				ИмяКаталога = ОбъединитьПути(КаталогИерархическойВыгрузки, ИмяНовогоФайла);
				ФайлКаталога = Новый Файл(ИмяКаталога);
				Если ФайлКаталога.Существует() = Ложь Тогда
					СоздатьКаталог(ИмяКаталога);
				КонецЕсли;
				Продолжить;
			КонецЕсли;
			ИмяФайлаДляПереименования = ИмяНовогоФайла;
		Иначе
			Если Файл.ЭтоКаталог() Тогда
				ОбработатьКаталогРезультатаВыгрузки(Файл, КаталогИерархическойВыгрузки, Переименования);
				Продолжить;
			КонецЕсли;

			ИмяФайла = СкорректироватьИмяФайлаМетаданных(Файл.ИмяБезРасширения);

			//Определим длину Наименования папки, по умолчанию не больше 60 символов.
			Если СтрДлина(ИмяФайла)>144 Тогда
				СократитьДлинуИмениФайла(ИмяФайла, КаталогИерархическойВыгрузки);
			КонецЕсли;

			ИмяНовогоФайла = СтрЗаменить(ИмяФайла, ".", ПолучитьРазделительПути())+Файл.Расширение;

		КонецЕсли;

		НовыйФайл = Новый Файл(ОбъединитьПути(КаталогИерархическойВыгрузки, ИмяНовогоФайла));
		НовыйКаталог = Новый Файл(НовыйФайл.Путь);
		Если НЕ НовыйКаталог.Существует() Тогда
			СоздатьКаталог(НовыйКаталог.ПолноеИмя);
		КонецЕсли;

		ДобавитьПереименование(Переименования,ИмяФайлаДляПереименования,ИмяНовогоФайла);

		КопироватьФайл(Файл.ПолноеИмя, НовыйФайл.ПолноеИмя);

		Если Нрег(Файл.Имя) = "form.bin" Тогда
			КаталогФормы = ОбъединитьПути(НовыйКаталог.ПолноеИмя, НовыйФайл.ИмяБезРасширения);
			СоздатьКаталог(КаталогФормы);
			РаспаковатьКонтейнерМетаданных(НовыйФайл.ПолноеИмя, КаталогФормы, Переименования, ФайлВыгрузкиКаталог.ПолноеИмя + ПолучитьРазделительПути());
		КонецЕсли;

	КонецЦикла;

	ТекстовыйДокумент = Новый ЗаписьТекста(ОбъединитьПути(КаталогИерархическойВыгрузки, "renames.txt"));
	Для Каждого ЭлементСтроки Из Переименования Цикл
		ТекстовыйДокумент.ЗаписатьСтроку(ЭлементСтроки.Источник+"-->"+СтрЗаменить(ЭлементСтроки.Приемник, "/", "\"));
	КонецЦикла;
	ТекстовыйДокумент.Закрыть();

КонецПроцедуры

Функция ЭтоНативнаяИерархия(Знач КаталогПроверки)
    КаталогЯзыки = Новый Файл(ОбъединитьПути(КаталогПроверки, "Languages"));
    Возврат КаталогЯзыки.Существует();
КонецФункции

Процедура ОчиститьЦелевойКаталогВыгрузки(Знач КаталогИерархическойСтруктурыМодулей)

	СоответствиеИменФайловДляПропуска = Новый Соответствие;
	СоответствиеИменФайловДляПропуска.Вставить(".git", Истина);
	СоответствиеИменФайловДляПропуска.Вставить(ИмяФайлаАвторов(), Истина); //Соответствие авторов и транслитерации.
	СоответствиеИменФайловДляПропуска.Вставить(ИмяФайлаВерсииХранилища(), Истина); //Номер версии, может использоватся для синхронизации с хранилищем.
	СоответствиеИменФайловДляПропуска.Вставить(ИмяФайлаСпискаЗадач(), Истина); //Список задач, может использоватся для синхронизации с хранилищем.

	//Удалим все каталоги с файлами в папке для разбора, кроме папки, начинающейся с с точки.
	ЕстьОшибкаУдаления = Ложь;
	Для НомерПопытки = 1 По 2 Цикл
		МассивФайлов = НайтиФайлы(КаталогИерархическойСтруктурыМодулей, ПолучитьМаскуВсеФайлы());
		Если МассивФайлов.Количество() = 0 Тогда
			Прервать;
		КонецЕсли;

		Для Каждого ЭлементМассива Из МассивФайлов Цикл
			Если СоответствиеИменФайловДляПропуска[ЭлементМассива.Имя] = Истина Тогда
				Продолжить;
			КонецЕсли;

			Попытка
				УдалитьФайлы(ЭлементМассива.ПолноеИмя);
			Исключение
				ЕстьОшибкаУдаления = Истина;
				Если НомерПопытки = 2 Тогда
					ВызватьИсключение;
				КонецЕсли;
			КонецПопытки;
		КонецЦикла;

		Если Не ЕстьОшибкаУдаления Тогда
			Прервать;
		КонецЕсли;

	КонецЦикла;

КонецПроцедуры

Процедура ОбработатьКаталогРезультатаВыгрузки(Знач Файл, Знач КаталогИерархическойСтруктурыМодулей, Знач Переименования)
	Если Прав(Файл.Имя, 5) = "files" Тогда // файлы справки.
		МассивФайлов = НайтиФайлы(Файл.ПолноеИмя, ПолучитьМаскуВсеФайлы());
		ИмяНовогоФайла = Лев(Файл.Имя, СтрДлина(Файл.Имя)-6);
		ИмяНовогоФайла = СтрЗаменить(ИмяНовогоФайла, ".", ПолучитьРазделительПути())+".del";
		НовыйФайл = Новый Файл(ОбъединитьПути(КаталогИерархическойСтруктурыМодулей, ИмяНовогоФайла));
		НовыйКаталог = Новый Файл(НовыйФайл.Путь);
		Если НЕ НовыйКаталог.Существует() Тогда
			СоздатьКаталог(НовыйКаталог.ПолноеИмя);
		КонецЕсли;
		НовыйФайл = Новый Файл(ОбъединитьПути(НовыйКаталог.ПолноеИмя, Файл.Имя));
		Если Не НовыйФайл.Существует() Тогда
			СоздатьКаталог(НовыйФайл.ПолноеИмя);
		КонецЕсли;
		Для Каждого ЭлементЦикла Из МассивФайлов Цикл
			ДобавитьПереименование(Переименования,
				ОбъединитьПути(Файл.Имя, ЭлементЦикла.Имя),
				СтрЗаменить(ОбъединитьПути(НовыйФайл.ПолноеИмя, ЭлементЦикла.Имя), КаталогИерархическойСтруктурыМодулей+ПолучитьРазделительПути(), ""));
		КонецЦикла;
	КонецЕсли;
КонецПроцедуры

Функция СкорректироватьИмяФайлаМетаданных(Знач ИмяФайла)

	Если Прав(ИмяФайла, 12) = "Форма.Модуль" Тогда
		ИмяФайла = Лев(ИмяФайла, СтрДлина(ИмяФайла)-12)+"МодульФормы";
	КонецЕсли;

	Если Прав(ИмяФайла, 6) = ".Макет" Тогда
		ИмяФайла = Лев(ИмяФайла, СтрДлина(ИмяФайла)-6);
	КонецЕсли;

	Если Прав(ИмяФайла, 17) = ".Картинка.Picture" Тогда
		ИмяФайла = Лев(ИмяФайла, СтрДлина(ИмяФайла)-17);
	КонецЕсли;

	Если Прав(ИмяФайла, 5) = ".Form" Тогда

	КонецЕсли;

	// Для 8.3 если файл содержит всего одну точку в имени, тогда создадим папки и туда его и кинем.
	//

	Если СтрЧислоВхождений(ИмяФайла, ".") = 1 Тогда
		//Увеличим наименование на Наименование объекта конфигурации описываемого.
		НаименованиеОбъектаМетаданных = Сред(ИмяФайла, Найти(ИмяФайла, "."));
		ИмяФайла = СтрЗаменить(ИмяФайла, НаименованиеОбъектаМетаданных,НаименованиеОбъектаМетаданных+НаименованиеОбъектаМетаданных);
	КонецЕсли;

	Возврат ИмяФайла;

КонецФункции

Процедура СократитьДлинуИмениФайла(ИмяФайла, Знач КаталогИерархическойСтруктурыМодулей)

	КэшПереименований = Новый Соответствие;
	МассивИмен = СтроковыеФункции.РазложитьСтрокуВМассивПодстрок(ИмяФайла, ".");

	ИмяФайла = "";
	Счетчик = 0;
	КоличествоВсего = МассивИмен.Количество();
	Для Счетчик = 0 По КоличествоВсего-1 Цикл
		ЭлементМассива = МассивИмен.Получить(Счетчик);
		НовоеИмя = ЭлементМассива;
		ДлинаИмени = СтрДлина(ЭлементМассива);

		Если ДлинаИмени > 58 Тогда
			Лог.Отладка("Слишком длинное имя:"+ЭлементМассива +" длина:"+ДлинаИмени);

			Если КэшПереименований.Получить(ЭлементМассива) <> Неопределено Тогда
				НовоеИмя = КэшПереименований.Получить(ЭлементМассива);
			Иначе
				Разрядность = СтрДлина(Строка(ДлинаИмени));
				НовоеИмя = Лев(ЭлементМассива, 58-Разрядность-1)+"~"+ДлинаИмени;
				НовыйПутьПроверки = Новый Файл(КаталогИерархическойСтруктурыМодулей + ПолучитьРазделительПути()+ ИмяФайла + НовоеИмя);
				Если НовыйПутьПроверки.Существует() Тогда
					СчетчикНовогоИмени = 0;
					МассивФайловСущуствующих = НайтиФайлы(ОбъединитьПути(КаталогИерархическойСтруктурыМодулей, ИмяФайла), Лев(ЭлементМассива, 58-Разрядность-3)+"*");
					СчетчикНовогоИмени = МассивФайловСущуствующих.Количество()+1;
					НовоеИмя = Лев(ЭлементМассива, 58-Разрядность-3)+"~"+ДлинаИмени+ФорматДвузначноеЧисло(Строка(СчетчикНовогоИмени));
				КонецЕсли;

				КэшПереименований.Вставить(ЭлементМассива, НовоеИмя);
			КонецЕсли;

			Лог.Отладка("Старое имя:"+ЭлементМассива +" новое имя:"+НовоеИмя);
		КонецЕсли;
		ИмяФайла=ИмяФайла+НовоеИмя+ПолучитьРазделительПути();
	КонецЦикла;
	ИмяФайла = ?(Прав(ИмяФайла,1)=ПолучитьРазделительПути(), Лев(ИмяФайла, СтрДлина(ИмяФайла)-1), ИмяФайла);

КонецПроцедуры

Процедура РаспаковатьКонтейнерМетаданных(Знач ФайлРаспаковки, Знач КаталогРаспаковки, Знач Переименования = "", Знач КорневойКаталог = "")

	dllРаспаковать(ФайлРаспаковки, КаталогРаспаковки);
	ВыполнитьСборкуМусора(); // см. камент к процедуре dllРаспаковать

	Если ПереименовыватьФайлМодуляОбычнойФормы Тогда

		Для Каждого ФайлМодуля Из НайтиФайлы(КаталогРаспаковки, "module", Истина) Цикл

			СтароеИмяФайла = ФайлМодуля.ПолноеИмя;
			НовоеИмяФайла = ОбъединитьПути(ФайлМодуля.Путь, "Module.bsl");
			ПереместитьФайл(СтароеИмяФайла, НовоеИмяФайла);
			Если НЕ ПустаяСтрока(Переименования) Тогда
				Если ПустаяСтрока(КорневойКаталог) Тогда
					ВызватьИсключение 
						"РаспаковатьКонтейнерМетаданных при заполненном Переименования ожидали и не пустое КорневойКаталог";
				КонецЕсли;
				ДобавитьПереименование(Переименования,
					СтрЗаменить(СтароеИмяФайла, КорневойКаталог, ""),
					СтрЗаменить(НовоеИмяФайла, КорневойКаталог, ""));
			КонецЕсли;
		КонецЦикла;

	КонецЕсли;

КонецПроцедуры

// хитрость: надо выносить в отдельную процедуру, 
// а сборку мусора делать в другом кадре стека вызовов.
// иначе сборка ничего не соберет
//
Процедура dllРаспаковать(Знач ФайлРаспаковки, Знач КаталогРаспаковки)
		
	Распаковщик = Новый ЧтениеФайла8(ФайлРаспаковки);
	Распаковщик.ИзвлечьВсе(КаталогРаспаковки, Истина);
	ОсвободитьОбъект(Распаковщик); // почему-то этого недостаточно. Вопрос к реализации компоненты.
	Распаковщик = Неопределено;
	
КонецПроцедуры

/////////////////////////////////////
// GIT Пересмотр

Функция ПолучитьГитРепозиторий(Знач КаталогРабочейКопии)

	ФайлКаталога = Новый Файл(ОбъединитьПути(ТекущийКаталог(), КаталогРабочейКопии));
	Если ФайлКаталога.ПолноеИмя = РабочийКаталогСохр Тогда
		ГитРепозиторий = ГитРепозиторийСохр;
	Иначе
		ГитРепозиторий = Новый ГитРепозиторий;
		ГитРепозиторий.УстановитьРабочийКаталог(КаталогРабочейКопии);
		ГитРепозиторий.УстановитьНастройку("core.quotepath", "false", РежимУстановкиНастроекGit.Локально);
		ГитРепозиторий.УстановитьНастройку("merge.ours.driver", "true", РежимУстановкиНастроекGit.Локально);

		РабочийКаталогСохр = ФайлКаталога.ПолноеИмя;
		ГитРепозиторийСохр = ГитРепозиторий;

	КонецЕсли;

	Возврат ГитРепозиторий;

КонецФункции // ПолучитьГитРепозиторий()

Функция ПодготовитьФайлКоммита(Знач Комментарий)

	ИмяФайлаКомментария = ВременныеФайлы.СоздатьФайл("txt");
	ФайлКомментария = Новый ЗаписьТекста(ИмяФайлаКомментария, КодировкаТекста.UTF8NoBOM);
	ФайлКомментария.Записать(?(ПустаяСтрока(Комментарий), ".", Комментарий));
	ФайлКомментария.Закрыть();
	Лог.Отладка(СтрШаблон("Текст коммита: %1", Комментарий));

	Возврат ИмяФайлаКомментария;

КонецФункции


// Выполняет фиксацию изменений в локальном каталоге git
//
Процедура ВыполнитьКоммитГит(Знач КаталогРабочейКопии, Знач Комментарий, Знач Автор, Знач Дата = Неопределено, Знач НоваяМетка = "") Экспорт

	Если Дата = Неопределено Тогда
		Дата = ТекущаяДата();
	КонецЕсли;

	авторДляГит = Автор;
	
	Лог.Отладка(СтрШаблон("Автор коммита: %1", авторДляГит));
	ДатаДляГит = ДатаPOSIX(Дата);
	Лог.Отладка(СтрШаблон("Дата коммита: %1", ДатаДляГит));
	ИмяФайлаКомментария = ПодготовитьФайлКоммита(Комментарий);
	
	ГитРепозиторий = ПолучитьГитРепозиторий(КаталогРабочейКопии);
	// Выполнение индексации всех измененных файлов
	ГитРепозиторий.ВыполнитьКоманду(СтрРазделить("add -A .", " "));
	ГитРепозиторий.Закоммитить(Комментарий,
	                           Истина,
							   ИмяФайлаКомментария,
							   авторДляГит,
							   ДатаДляГит,
							   авторДляГит,
							   ДатаДляГит);
	Лог.Отладка(СтрШаблон("Вывод команды Commit: %1", СокрЛП(ГитРепозиторий.ПолучитьВыводКоманды())));
	
	Если ЗначениеЗаполнено(НоваяМетка) Тогда
		ПараметрыКоманды = Новый Массив;
		ПараметрыКоманды.Добавить("tag");
		ПараметрыКоманды.Добавить(Строка(НоваяМетка));
	
		ГитРепозиторий.ВыполнитьКоманду(ПараметрыКоманды);
		
	КонецЕсли;
	
	ЗавершитьПроцесс_TGitCache_exe();

КонецПроцедуры

// Cтандартная процедура git push
//
Функция ВыполнитьGitPush(Знач ЛокальныйРепозиторий, Знач УдаленныйРепозиторий, Знач ИмяВетки = Неопределено, Знач ОтправитьМетки = Ложь) Экспорт

	ГитРепозиторий = ПолучитьГитРепозиторий(ЛокальныйРепозиторий);
	// Оптимизация git
	ГитРепозиторий.ВыполнитьКоманду(СтрРазделить("gc --auto", " "));
	Лог.Отладка(СтрШаблон("Вывод команды gc: %1", СокрЛП(ГитРепозиторий.ПолучитьВыводКоманды())));
	
	ПараметрыКомандыPush = Новый Массив;
	ПараметрыКомандыPush.Добавить("push -u");
	ПараметрыКомандыPush.Добавить(СтрЗаменить(УдаленныйРепозиторий, "%", "%%"));
	ПараметрыКомандыPush.Добавить("--all -v");

	ГитРепозиторий.ВыполнитьКоманду(ПараметрыКомандыPush);

	Лог.Отладка(СтрШаблон("Вывод команды Push: %1", СокрЛП(ГитРепозиторий.ПолучитьВыводКоманды())));

	ЗавершитьПроцесс_TGitCache_exe();

	Возврат 0;

КонецФункции

// Cтандартная процедура git pull
//
Функция ВыполнитьGitPull(Знач ЛокальныйРепозиторий, Знач УдаленныйРепозиторий, Знач ИмяВетки) Экспорт


	ГитРепозиторий = ПолучитьГитРепозиторий(ЛокальныйРепозиторий);
	ГитРепозиторий.Получить(УдаленныйРепозиторий, ИмяВетки);

	Лог.Отладка(СтрШаблон("Вывод команды Pull: %1", СокрЛП(ГитРепозиторий.ПолучитьВыводКоманды())));

	ЗавершитьПроцесс_TGitCache_exe();

	Возврат 0;

КонецФункции

//////////////////////////////////////////////////////////////////////////
// Работа с таблицами хранилища 1С


// Устанавливает параметры авторизации в хранилище 1С, если выгрузка версии выполняется средствами платформы
//
Процедура УстановитьАвторизациюВХранилищеКонфигурации(Знач Логин, Знач Пароль, Знач ВерсияПлатформы = "")

	мАвторизацияВХранилищеСредствами1С = Новый Структура;
	мАвторизацияВХранилищеСредствами1С.Вставить("Логин" , Логин);
	мАвторизацияВХранилищеСредствами1С.Вставить("Пароль", Пароль);
	мАвторизацияВХранилищеСредствами1С.Вставить("ВерсияПлатформы", ВерсияПлатформы);

КонецПроцедуры

// Выполняет чтение таблицы VERSIONS из хранилища 1С
//
// Возвращаемое значение: ТаблицаЗначений
//
Функция ПрочитатьТаблицуИсторииХранилища(Знач ФайлХранилища) Экспорт

	ЧтениеБазыДанных = Новый ЧтениеТаблицФайловойБазыДанных;
	ЧтениеБазыДанных.ОткрытьФайл(ФайлХранилища);
	Попытка
		ТаблицаБД = ЧтениеБазыДанных.ПрочитатьТаблицу("VERSIONS");
	Исключение
		ЧтениеБазыДанных.ЗакрытьФайл();
		ВызватьИсключение;
	КонецПопытки;

	ЧтениеБазыДанных.ЗакрытьФайл();

	ТаблицаВерсий = КонвертироватьТаблицуВерсийИзФорматаБД(ТаблицаБД);
	ТаблицаВерсий.Сортировать("НомерВерсии");

	Возврат ТаблицаВерсий;

КонецФункции

// Считывает таблицу USERS пользователей хранилища
//
Функция ПрочитатьТаблицуПользователейХранилища(Знач ФайлХранилища) Экспорт

	ЧтениеБазыДанных = Новый ЧтениеТаблицФайловойБазыДанных;
	ЧтениеБазыДанных.ОткрытьФайл(ФайлХранилища);
	Попытка
		ТаблицаБД = ЧтениеБазыДанных.ПрочитатьТаблицу("USERS");
	Исключение
		ЧтениеБазыДанных.ЗакрытьФайл();
		ВызватьИсключение;
	КонецПопытки;

	ЧтениеБазыДанных.ЗакрытьФайл();

	Возврат КонвертироватьТаблицуПользователейИзФорматаБД(ТаблицаБД);

КонецФункции

// Считывает из хранилища историю коммитов с привязкой к пользователям
//
Функция ПрочитатьИзХранилищаИсториюКоммитовСАвторами(Знач ФайлХранилища) Экспорт

	Перем ТаблицаВерсий;
	Перем ТаблицаПользователей;

	ЧтениеБазыДанных = Новый ЧтениеТаблицФайловойБазыДанных;
	ЧтениеБазыДанных.ОткрытьФайл(ФайлХранилища);
	Попытка
		Таблицы = ЧтениеБазыДанных.ВыгрузитьТаблицыВXML("USERS;VERSIONS");
		ТаблицаВерсий        = ЧтениеБазыДанных.ПрочитатьТаблицуИзXml(Таблицы["VERSIONS"]);
		ТаблицаПользователей = ЧтениеБазыДанных.ПрочитатьТаблицуИзXml(Таблицы["USERS"]);
	Исключение
		ЧтениеБазыДанных.ЗакрытьФайл();
		ВызватьИсключение;
	КонецПопытки;

	ЧтениеБазыДанных.ЗакрытьФайл();

	ТаблицаВерсий = КонвертироватьТаблицуВерсийИзФорматаБД(ТаблицаВерсий);
	ТаблицаПользователей = КонвертироватьТаблицуПользователейИзФорматаБД(ТаблицаПользователей);

	ДополнитьТаблицуВерсийИменамиАвторов(ТаблицаВерсий, ТаблицаПользователей);
	ТаблицаВерсий.Сортировать("НомерВерсии");

	Возврат ТаблицаВерсий;

КонецФункции

// Прописывает в таблицы пользователей и версий информацию о git auth вида user <user@email.com>
//
Процедура ДополнитьТаблицуХранилищаИнформациейОСигнатуреПользователяВГит(Знач ТаблицаХранилища, Знач КаталогРепо, Знач ПроверитьАвторовХранилища = Ложь) Экспорт

	ПутьКФайлуСопоставления = ОбъединитьПути(КаталогРепо, ИмяФайлаАвторов());
	ТаблицаСопоставления = ПрочитатьФайлАвторовГитВТаблицуПользователей(ПутьКФайлуСопоставления);
	СоответствиеСообщенийОбОшибочныхАвторах = Новый Соответствие;
	Для Каждого Строка Из ТаблицаХранилища Цикл

		СтрокаПользователя = ТаблицаСопоставления.Найти(строка.Автор, "Автор");
		Если СтрокаПользователя = Неопределено Тогда
			
			СтрокаСообщения = СтрШаблон("Пользователю хранилища <%1> не сопоставлен пользователь git.",строка.Автор);
			Если ПроверитьАвторовХранилища Тогда
				СоответствиеСообщенийОбОшибочныхАвторах.Вставить(строка.Автор, СтрокаСообщения);
			КонецЕсли;
			Лог.Отладка(СтрокаСообщения + " Использую сопоставление по умолчанию");
			ПредставлениеАвтора = СтроковыеФункции.ПодставитьПараметрыВСтроку("%1 <%1@%2>", строка.Автор, Строка(ДоменПочтыДляGit()));
		Иначе
			ПредставлениеАвтора = строкаПользователя.ПредставлениеАвтора;
		КонецЕсли;

		Строка.ПредставлениеАвтора = ПредставлениеАвтора;

	КонецЦикла;

	Если СоответствиеСообщенийОбОшибочныхАвторах.Количество() > 0 Тогда
		Для каждого КлючЗначение Из СоответствиеСообщенийОбОшибочныхАвторах Цикл
		         Лог.КритичнаяОшибка(КлючЗначение.Значение);
		КонецЦикла;

		ВызватьИсключение СтрШаблон("В таблице истории версий найдены авторы (количество %1), которые не сопоставлены в AUTHORS",СоответствиеСообщенийОбОшибочныхАвторах.Количество());

	КонецЕсли;

КонецПроцедуры

Функция КонвертироватьТаблицуВерсийИзФорматаБД(Знач ТаблицаБД)

	ТаблицаВерсий = НоваяТаблицаИсторииВерсий();

	Для Каждого СтрокаБД Из ТаблицаБД Цикл

		Если СтрокаБД.VERDATE = "0000-00-00T00:00:00" Тогда
			Продолжить;
		КонецЕсли;

		НоваяСтрока = ТаблицаВерсий.Добавить();
		НоваяСтрока.НомерВерсии = Число(СтрокаБД.VERNUM);
		НоваяСтрока.ГУИД_Автора = СтрокаБД.USERID;
		НоваяСтрока.Тэг = СтрокаБД.CODE;

		Дата = СтрЗаменить(СтрЗаменить(СтрокаБД.VERDATE, "-", ""), ":", "");
		Дата = СтрЗаменить(Дата, "T", "");
		Дата = Дата(Дата);
		НоваяСтрока.Дата = Дата;
		НоваяСтрока.Комментарий = СтрокаБД.COMMENT;

	КонецЦикла;

	Возврат ТаблицаВерсий;
КонецФункции

Функция КонвертироватьТаблицуПользователейИзФорматаБД(Знач ТаблицаБД)
	ТаблицаПользователей = НоваяТаблицаПользователейХранилища();

	Для Каждого СтрокаБД Из ТаблицаБД Цикл

		НоваяСтрока = ТаблицаПользователей.Добавить();
		НоваяСтрока.Автор       = СтрокаБД.NAME;
		НоваяСтрока.ГУИД_Автора = СтрокаБД.USERID;

	КонецЦикла;

	Возврат ТаблицаПользователей;

КонецФункции

Функция НоваяТаблицаИсторииВерсий()

	Таблица = Новый ТаблицаЗначений;
	Таблица.Колонки.Добавить("НомерВерсии");
	Таблица.Колонки.Добавить("ГУИД_Автора");
	Таблица.Колонки.Добавить("Автор");
	Таблица.Колонки.Добавить("Тэг");
	Таблица.Колонки.Добавить("Дата");
	Таблица.Колонки.Добавить("Комментарий");
	Таблица.Колонки.Добавить("ПредставлениеАвтора");

	Возврат Таблица;

КонецФункции

Функция НоваяТаблицаПользователейХранилища()

	Таблица = Новый ТаблицаЗначений;
	Таблица.Колонки.Добавить("Автор");
	Таблица.Колонки.Добавить("ГУИД_Автора");
	Таблица.Колонки.Добавить("ПредставлениеАвтора");

	Возврат Таблица;

КонецФункции

Функция НоваяТаблицаЗадач()
	
	Таблица = Новый ТаблицаЗначений;
	Таблица.Колонки.Добавить("НомерЗадачи");
	Таблица.Колонки.Добавить("ОписаниеЗадачи");

	Возврат Таблица;	
КонецФункции

Процедура ДополнитьТаблицуВерсийИменамиАвторов(Знач ТаблицаВерсий, Знач ТаблицаПользователей)

	Для Каждого Строка Из ТаблицаВерсий Цикл
		строкаПользователя = ТаблицаПользователей.Найти(Строка.ГУИД_Автора, "ГУИД_Автора");
		Если строкаПользователя = Неопределено Тогда
			Сообщение = "Не удалось найти автора коммита из хранилища 1С по номеру версии <%1>, комментарий <%2>, ГУИД-у <%3> - ПолучитьТаблицуВерсийИзФайлаХранилища1С";
			Лог.Ошибка(СтроковыеФункции.ПодставитьПараметрыВСтроку(Сообщение, строка.НомерВерсии, строка.Комментарий, строка.ГУИД_Автора));
		Иначе
			строка.Автор = строкаПользователя.Автор;
		КонецЕсли;
	КонецЦикла;

КонецПроцедуры

Процедура ДополнитьТаблицаИсторииХранилищаДаннымиОЗадачах(ТаблицаИсторииХранилища, КаталогРабочейКопии)
	
	ПутьКФайлуЗадач = ОбъединитьПути(КаталогРабочейКопии, ИмяФайлаСпискаЗадач());

	ТаблицаЗадач = ПрочитатьФайлСоСпискомЗадачВТаблицуЗадач(ПутьКФайлуЗадач);

	Если ТаблицаЗадач = Неопределено
		ИЛИ ТаблицаЗадач.Количество() = 0 Тогда
		Возврат;
	Конецесли;

	Для Каждого СтрокаТаблицаИсторииХранилища Из ТаблицаИсторииХранилища Цикл
		пКомментарий = СтрокаТаблицаИсторииХранилища.Комментарий;

		МассивЗадач = ПолучитьМассивНомеровЗадачИзТекста(пКомментарий);

		Если МассивЗадач.Количество() = 0 Тогда
			Продолжить;
		Конецесли;

		Если МассивЗадач.Количество() > 1 Тогда
			ВызватьИсключение "Ошибка! обнаружено более 1 задачи, нет алгоритма для обработки такой ситуации";
		Конецесли;

		НомерЗадачи = МассивЗадач[0];

		СтрокаТаблицаЗадач = ТаблицаЗадач.Найти(НомерЗадачи, "НомерЗадачи");

		Если СтрокаТаблицаЗадач <> Неопределено Тогда
			пКомментарий = СтрЗаменить(пКомментарий,"#"+НомерЗадачи,СтрокаТаблицаЗадач.ОписаниеЗадачи)	
		КонецЕсли;

		СтрокаТаблицаИсторииХранилища.Комментарий = пКомментарий;

	КонецЦикла;
	
КонецПроцедуры

Функция ПрочитатьФайлСоСпискомЗадачВТаблицуЗадач(ПутьКФайлуЗадач)

	Если НЕ ЗначениеЗаполнено(ПутьКФайлуЗадач) Тогда
		Возврат Неопределено;
	КонецЕсли;

	Файл = Новый Файл(ПутьКФайлуЗадач);
	Если Не Файл.Существует() Тогда
		Возврат НоваяТаблицаЗадач();
	КонецЕсли;

	ТаблицаЗадач = НоваяТаблицаЗадач();

	Попытка
		ТекстовыйФайл = Новый ЧтениеТекста(ПутьКФайлуЗадач,"utf-8");
		СтрокаФайла = "";
		Пока СтрокаФайла <> Неопределено Цикл
			СтрокаФайла = ТекстовыйФайл.ПрочитатьСтроку();

			МассивНомеровЗадач = ПолучитьМассивНомеровЗадачИзТекста(СтрокаФайла);
			Если МассивНомеровЗадач.Количество() = 0 Тогда
				Продолжить;
			Конецесли;

			Если МассивНомеровЗадач.Количество() > 1 Тогда
				ВызватьИсключение "Ошибка! Найдено более 1 задачи в СтрокеФайла " + СтрокаФайла + " Файл " + ПутьКФайлуЗадач;
			Конецесли;			

			НомерЗадачи = МассивНомеровЗадач[0];

			НоваяСтрока = ТаблицаЗадач.Добавить();
			НоваяСтрока.НомерЗадачи = НомерЗадачи;
			НоваяСтрока.ОписаниеЗадачи = СтрокаФайла;		
		КонецЦикла;

	Исключение
		Если ТекстовыйФайл <> Неопределено Тогда
			ОсвободитьОбъект(ТекстовыйФайл);
		КонецЕсли;
		ВызватьИсключение;
	КонецПопытки;

	Если ТекстовыйФайл <> Неопределено Тогда
		ОсвободитьОбъект(ТекстовыйФайл);
	КонецЕсли;

	Возврат ТаблицаЗадач;

КонецФункции

Функция ПолучитьМассивНомеровЗадачИзТекста(Текст) Экспорт
	
	МассивНомеровЗадач = Новый Массив();
	
	ЧислоУказанныхЗадач = СтрЧислоВхождений(Текст, "#");
	Если ЧислоУказанныхЗадач = 0 Тогда
		Возврат МассивНомеровЗадач;
	Конецесли;
	
	Для НомерВхождения = 1 По ЧислоУказанныхЗадач Цикл
		
		ПозРешетка = СтрНайти(Текст, "#",,,НомерВхождения);
		ТекстНомерЗадачи = "#";
		НомерЗадачи = "";
		
		НомерСимвола = ПозРешетка + 1;
		Символ = Сред(Текст,НомерСимвола,1);
		Пока 48<= КодСимвола(Символ)  
			И  КодСимвола(Символ) <= 57 Цикл
			
			НомерЗадачи = НомерЗадачи + Символ;
			НомерСимвола = НомерСимвола + 1;
			Символ = Сред(Текст,НомерСимвола,1);
		Конеццикла;

		НомерЗадачи = СокрЛП(НомерЗадачи);
		
		Если НЕ ЗначениеЗаполнено(НомерЗадачи) Тогда
			Продолжить;
		Конецесли;
		
		НомерЗадачи = Число(НомерЗадачи);
		
		Если МассивНомеровЗадач.Найти(НомерЗадачи) = Неопределено Тогда
			МассивНомеровЗадач.Добавить(НомерЗадачи);
		Конецесли;
	КонецЦикла;	
	
	Возврат МассивНомеровЗадач;	

КонецФункции 

// Генерирует файл соответствия пользователей хранилища 1С и git
//
Процедура СформироватьПервичныйФайлПользователейДляGit(Знач ИмяФайлаХранилища, Знач ВыходнойФайл) Экспорт

	резПутьКХМЛФайлуВерсийХранилища1С = "";
	резПутьКХМЛФайлуПользователейХранилища1С = "";

	Лог.Отладка("Формируем первичный файл авторов:
	| Файл хранилища: " + ИмяФайлаХранилища + "
	| Выходной файл: " + ВыходнойФайл);

	ТаблицаПользователейХранилища = ПрочитатьТаблицуПользователейХранилища(ИмяФайлаХранилища);

	ЗаписатьТаблицуПользователейВФайлАвторовGit(ТаблицаПользователейХранилища, ВыходнойФайл, ДоменПочтыДляGit());

КонецПроцедуры

Процедура ЗаписатьТаблицуПользователейВФайлАвторовGit(Знач ТаблицаПользователейХранилища, Знач ВыходнойФайл, Знач ДоменПочтыДляGit)

	ЗаписьФайла = Новый ЗаписьТекста(ВыходнойФайл, "utf-8");
	Попытка
		ШаблонЗаписи = "%1=%1 <%1@%2>";
		Для Каждого Запись Из ТаблицаПользователейХранилища Цикл
			СтрокаДляЗаписи = СтроковыеФункции.ПодставитьПараметрыВСтроку(ШаблонЗаписи, Запись.Автор, ДоменПочтыДляGit);
			ЗаписьФайла.ЗаписатьСтроку(СтрокаДляЗаписи);
		КонецЦикла;

		ЗаписьФайла.Закрыть();
	Исключение
		ОсвободитьОбъект(ЗаписьФайла);
		ВызватьИсключение;
	КонецПопытки;

КонецПроцедуры

// Выполняет клонирование удаленного репо
//
Функция КлонироватьРепозитарий(Знач КаталогЛокальнойКопии, Знач URLРепозитария) Экспорт

	Батник = Новый КомандныйФайл();
	// Батник.ДобавитьКоманду("chcp 1251 > nul");
	Если ЭтоWindows Тогда
		Батник.ДобавитьКоманду(СтроковыеФункции.ПодставитьПараметрыВСтроку("cd /d ""%1""", КаталогЛокальнойКопии));
	Иначе
		Батник.ДобавитьКоманду(СтроковыеФункции.ПодставитьПараметрыВСтроку("cd ""%1""", КаталогЛокальнойКопии));
	КонецЕсли;
	ФайлЛога = ВременныеФайлы.СоздатьФайл("log");
	ПараметрыКоманды = Новый Массив;
	ПараметрыКоманды.Добавить("git clone");
	ПараметрыКоманды.Добавить(URLРепозитария);
	ПараметрыКоманды.Добавить(ОбернутьВКавычки(КаталогЛокальнойКопии));
	ПараметрыКоманды.Добавить(Батник.СуффиксПеренаправленияВывода(ФайлЛога, Истина));

	КоманднаяСтрока = СобратьКоманднуюСтроку(ПараметрыКоманды);
	Лог.Отладка(КоманднаяСтрока);
	Батник.ДобавитьКоманду(КоманднаяСтрока);
	Батник.ДобавитьКоманду("exit " + ?(ЭтоWindows, "/b %ERRORLEVEL%", "$#"));

	РезультатКлонирования = Батник.Исполнить();

	ВывестиТекстФайла(ФайлЛога);
	УдалитьВременныеФайлыПриНеобходимости(ФайлЛога);
	УдалитьВременныеФайлыПриНеобходимости(Батник.Закрыть());
	Возврат РезультатКлонирования;

КонецФункции

// Выполняет инициализацию репо
//
Функция ИнициализироватьРепозитарий(Знач КаталогЛокальнойКопии) Экспорт

	Батник = Новый КомандныйФайл;
	Лог.Отладка(КаталогЛокальнойКопии);
	ДопСтрокаПерехода = ?(ЭтоWindows, "/d", "");
	Батник.ДобавитьКоманду(СтроковыеФункции.ПодставитьПараметрыВСтроку("cd %2 ""%1""", КаталогЛокальнойКопии, ДопСтрокаПерехода));
	ФайлЛога = ВременныеФайлы.СоздатьФайл("log");
	ПараметрыКоманды = Новый Массив;
	ПараметрыКоманды.Добавить("git init");
	ПараметрыКоманды.Добавить(Батник.СуффиксПеренаправленияВывода(ФайлЛога, Истина));

	КоманднаяСтрока = СобратьКоманднуюСтроку(ПараметрыКоманды);
	Лог.Отладка(КоманднаяСтрока);
	Батник.ДобавитьКоманду(КоманднаяСтрока);
	Батник.ДобавитьКоманду("exit " + ?(ЭтоWindows, "/b %ERRORLEVEL%", "$#"));

	Результат = Батник.Исполнить();

	ВывестиТекстФайла(ФайлЛога);
	УдалитьВременныеФайлыПриНеобходимости(ФайлЛога);
	УдалитьВременныеФайлыПриНеобходимости(Батник.Закрыть());
	Возврат Результат;

КонецФункции

// Возвращает Истина, если каталог является каталогом или подкаталогом гит-репозитория, иначе возвращается Ложь.
//
Функция ПроверитьНаличиеРепозитарияГит(Знач КаталогЛокальнойКопии) Экспорт
	Батник = Новый КомандныйФайл;
	Лог.Отладка(КаталогЛокальнойКопии);
	
	ДопСтрокаПерехода = ?(ЭтоWindows, "/d", "");
	Батник.ДобавитьКоманду(СтрШаблон("cd %2 ""%1""", КаталогЛокальнойКопии, ДопСтрокаПерехода));
	ФайлЛога = ВременныеФайлы.СоздатьФайл("log");
	
	ПараметрыКоманды = Новый Массив;
	ПараметрыКоманды.Добавить("git status");
	ПараметрыКоманды.Добавить(Батник.СуффиксПеренаправленияВывода(ФайлЛога, Истина));

	КоманднаяСтрока = СобратьКоманднуюСтроку(ПараметрыКоманды);
	Лог.Отладка(КоманднаяСтрока);
	Батник.ДобавитьКоманду(КоманднаяСтрока);
	Батник.ДобавитьКоманду("exit " + ?(ЭтоWindows, "/b %ERRORLEVEL%", "$#"));

	КодВозврата = Батник.Исполнить();

	ВывестиТекстФайла(ФайлЛога);
	УдалитьВременныеФайлыПриНеобходимости(ФайлЛога);
	УдалитьВременныеФайлыПриНеобходимости(Батник.Закрыть());
	
	Возврат КодВозврата = 0;
КонецФункции // ПроверитьНаличиеРепозитарияГит(Знач Каталог) Экспорт

// Определяет необходимость синхронизации хранилища и репо GIT.
//
Функция ТребуетсяСинхронизироватьХранилищеСГит(Знач ФайлХранилища, Знач ЛокальныйКаталогГит) Экспорт

	ТаблицаВерсий = ПрочитатьТаблицуИсторииХранилища(ФайлХранилища);
	ТекущаяВерсия = НомерСинхронизированнойВерсии(ЛокальныйКаталогГит);
	МаксимальнаяВерсияДляРазбора = ОпределитьМаксимальнуюВерсиюВХранилище(ТаблицаВерсий);

	Лог.Информация("Номер синхронизированной версии: " + ТекущаяВерсия);
	Лог.Информация("Номер последней версии в хранилище: " + МаксимальнаяВерсияДляРазбора);

	Возврат ТекущаяВерсия < МаксимальнаяВерсияДляРазбора;

КонецФункции

// Основная функция синхронизации. Перемещает в git набор коммитов хранилища 1С
//
Процедура СинхронизироватьХранилищеКонфигурацийСГит(Знач КаталогРабочейКопии, 
		Знач ПутьКХранилищу, 
		Знач НачальнаяВерсия = 0, 
		Знач КонечнаяВерсия = 0, 
		Знач Формат = Неопределено, 
		Знач КоличествоКоммитовДоPush = 0,
		Знач URLРепозитория = Неопределено,

		Знач Лимит = 0,
		Знач ПрерватьВыполнениеБезКомментарияКВерсии = Ложь,
		Знач ИмяВетки = Неопределено,
		Знач АвтоматическаяУстановкаТэговПоВерсиям = Ложь,
		Знач ПроверитьАвторовХранилища = Ложь,
		Знач ПараметрыДоступаКХранилищу = Неопределено) Экспорт

	
	
	Лог.Информация("Начало синхронизации с git");
	
	ФайлХранилища = РаспаковщикКонфигурации.ПолучитьПутьКБазеДанныхХранилища(ПутьКХранилищу);
	Лог.Отладка("Файл хранилища конфигурации: " + ФайлХранилища);
	
	ТаблицаИсторииХранилища = ПрочитатьИзХранилищаИсториюКоммитовСАвторами(ФайлХранилища);
	ДополнитьТаблицуХранилищаИнформациейОСигнатуреПользователяВГит(ТаблицаИсторииХранилища, КаталогРабочейКопии, ПроверитьАвторовХранилища);

	ДополнитьТаблицаИсторииХранилищаДаннымиОЗадачах(ТаблицаИсторииХранилища, КаталогРабочейКопии);

	ТекущаяВерсия = НомерСинхронизированнойВерсии(КаталогРабочейКопии);

	Лог.Информация("Номер синхронизированной версии: " + ТекущаяВерсия);
	СледующаяВерсия = ТекущаяВерсия + 1;
	
	Если НачальнаяВерсия > 0 Тогда
		СледующаяВерсия = Макс(НачальнаяВерсия, СледующаяВерсия);
	КонецЕсли;

	Если Лимит > 0 Тогда

		СтрокаТекущейВерсии = ТаблицаИсторииХранилища.Найти(ТекущаяВерсия, "НомерВерсии");
		ИндексСтрокиТекущейВерсии = ТаблицаИсторииХранилища.Индекс(СтрокаТекущейВерсии);
		ИндексСтрокиСОграничением = Мин(ТаблицаИсторииХранилища.Количество() - 1, ИндексСтрокиТекущейВерсии + Лимит);
		НомерВерсииСогласноЛимита = ТаблицаИсторииХранилища[ИндексСтрокиСОграничением].НомерВерсии;

		Если КонечнаяВерсия = 0 Тогда
			КонечнаяВерсия = НомерВерсииСогласноЛимита;
		Иначе
			КонечнаяВерсия = ?(КонечнаяВерсия >= НомерВерсииСогласноЛимита, КонечнаяВерсия, НомерВерсииСогласноЛимита);
		КонецЕсли;

	КонецЕсли;

	Если Формат = Неопределено Тогда
		Формат = РежимВыгрузкиФайлов.Авто;
	КонецЕсли;

	Если ПрерватьВыполнениеБезКомментарияКВерсии = Неопределено Тогда
		ПрерватьВыполнениеБезКомментарияКВерсии = Ложь;
	КонецЕсли;

	Лог.Отладка("Используется формат выгрузки " + Формат);

	МаксимальнаяВерсияДляРазбора = ОпределитьМаксимальнуюВерсиюСУчетомОграниченияСверху(ТаблицаИсторииХранилища, ТекущаяВерсия, КонечнаяВерсия);
	Лог.Информация("Номер последней версии в хранилище: " + МаксимальнаяВерсияДляРазбора);
	
	ИспользоватьПромежуточныйPUSH = КоличествоКоммитовДоPush > 0;
	СчетчикКоммитов = 0;
	
	СтрокаТекущейВерсии = ТаблицаИсторииХранилища.Найти(СледующаяВерсия, "НомерВерсии");
	ОтправитьНовыеМетки = Ложь;
	Если СтрокаТекущейВерсии <> Неопределено Тогда
		ПоследнняяВерсияКонфигурации = СтрокаТекущейВерсии.Тэг;
	КонецЕсли;

	Если СледующаяВерсия > МаксимальнаяВерсияДляРазбора И СледующаяВерсия - МаксимальнаяВерсияДляРазбора > МинимальнаяРазницаМеждуКоммитамиНовогоХранилища Тогда
		Лог.Ошибка("Несоответствие версий хранилища 1С и версию в репозитории Git. 
		|Возможно, сократили/обрезали хранилище. 
		|Для продолжения синхронизации измените файл VERSIONS в корне репозитория Git, 
		|Исправьте версию %1 на правильную версию <= версии в хранилище %2", ТекущаяВерсия, МаксимальнаяВерсияДляРазбора);
		
		ВызватьИсключение СтрШаблон("Версия git %1 больше версии хранилища %2 на %3", ТекущаяВерсия, МаксимальнаяВерсияДляРазбора, СледующаяВерсия - МаксимальнаяВерсияДляРазбора); 
	КонецЕсли;
	
	Пока СледующаяВерсия <= МаксимальнаяВерсияДляРазбора Цикл
				
		СтрокаВерсии = ТаблицаИсторииХранилища.Найти(СледующаяВерсия, "НомерВерсии");
		Если СтрокаВерсии <> Неопределено Тогда

			Если ПустаяСтрока(СтрокаВерсии.ПредставлениеАвтора) Тогда
				СтрокаОшибки = СтрШаблон("Нашли следующую версию <%1>, а автор <%2> не прописан", СледующаяВерсия, СтрокаВерсии.Автор);
				Лог.КритичнаяОшибка(СтрокаОшибки);
				ВызватьИсключение СтрокаОшибки;
			КонецЕсли;

			Если ПустаяСтрока(СтрокаВерсии.Комментарий) 
				И ПрерватьВыполнениеБезКомментарияКВерсии Тогда
				СтрокаОшибки = СтрШаблон("Нашли следующую версию <%1> от автора <%2>, а комментарий не задан!", СледующаяВерсия, СтрокаВерсии.Автор);
				Лог.КритичнаяОшибка(СтрокаОшибки);
				ВызватьИсключение СтрокаОшибки;
			КонецЕсли;

			НоваяМетка = "";
			Если ПоследнняяВерсияКонфигурации <> СтрокаВерсии.Тэг
				И АвтоматическаяУстановкаТэговПоВерсиям Тогда
				ОтправитьНовыеМетки = Истина;
				Лог.Информация("Определена новая версия конфигурации: %1 будет установлен новый тэг", СтрокаВерсии.Тэг);
				НоваяМетка = СтрокаВерсии.Тэг;
				ПоследнняяВерсияКонфигурации = НоваяМетка;
			КонецЕсли;

			Попытка
				Лог.Информация("Получаем исходники для версии " + СледующаяВерсия + ", " + ТекущаяДата());

				РазложитьМодулиПоНомеруВерсииХранилища1С(КаталогРабочейКопии, ПутьКХранилищу, СледующаяВерсия, Формат, ПараметрыДоступаКХранилищу);
				Лог.Отладка("Фиксируем в файле VERSION версию " + СледующаяВерсия);
				ЗаписатьФайлВерсийГит(КаталогРабочейКопии, СледующаяВерсия);
				ВыполнитьКоммитГит(КаталогРабочейКопии, СтрокаВерсии.Комментарий, СтрокаВерсии.ПредставлениеАвтора, СтрокаВерсии.Дата, НоваяМетка);
				СчетчикКоммитов = СчетчикКоммитов + 1;

				Если ИспользоватьПромежуточныйPUSH И
					СчетчикКоммитов = КоличествоКоммитовДоPush Тогда
					ВыполнитьGitPush(КаталогРабочейКопии, URLРепозитория, ИмяВетки, ОтправитьНовыеМетки);
					СчетчикКоммитов = 0;
					ОтправитьНовыеМетки  = Ложь;
				КонецЕсли;


			Исключение
				Лог.Отладка("Откатываем файл VERSION после ошибки");
				ЗаписатьФайлВерсийГит(КаталогРабочейКопии, ТекущаяВерсия);
				ВызватьИсключение;
			КонецПопытки;

			ТекущаяВерсия = СледующаяВерсия;
		КонецЕсли;

		СледующаяВерсия = СледующаяВерсия + 1;

	КонецЦикла;

	ЗавершитьПроцесс_TGitCache_exe();

КонецПроцедуры

Функция ОпределитьМаксимальнуюВерсиюСУчетомОграниченияСверху(Знач ТаблицаИсторииХранилища, Знач ТекущаяВерсия, Знач МаксимальнаяВерсия)

	МаксимальнаяВерсияДляРазбора = 0;
	ЧислоВерсийПлюс = 0;

	Если МаксимальнаяВерсия <> 0 Тогда
		Попытка
			МаксимальнаяВерсия = Число(МаксимальнаяВерсия);
		Исключение
			МаксимальнаяВерсия = 0;
		КонецПопытки;
	КонецЕсли;

	МаксВерсияВХранилище = ОпределитьМаксимальнуюВерсиюВХранилище(ТаблицаИсторииХранилища);

	Если МаксимальнаяВерсия > 0 Тогда
		МаксимальнаяВерсияДляРазбора = Мин(МаксВерсияВХранилище, МаксимальнаяВерсия) ;
	Иначе
		МаксимальнаяВерсияДляРазбора = МаксВерсияВХранилище;
	КонецЕсли;

	Возврат МаксимальнаяВерсияДляРазбора;

КонецФункции

Функция НомерСинхронизированнойВерсии(Знач КаталогВыгрузки)

	ПутьФайлаВерсий = ОбъединитьПути(КаталогВыгрузки, ИмяФайлаВерсииХранилища());

	ТекущаяВерсия = ПрочитатьФайлВерсийГит(ПутьФайлаВерсий);
	Если ТекущаяВерсия <> Неопределено Тогда
		Попытка
			ТекущаяВерсия=Число(ТекущаяВерсия);
		Исключение
			ТекущаяВерсия = 0;
		КонецПопытки;
	Иначе
		ТекущаяВерсия = 0;
	КонецЕсли;

	Возврат ТекущаяВерсия;

КонецФункции

Функция ОпределитьМаксимальнуюВерсиюВХранилище(Знач ТаблицаИсторииХранилища)

	Если ТаблицаИсторииХранилища.Количество() = 0 Тогда
		Возврат 0;
	КонецЕсли;

	МаксимальнаяВерсия = Число(ТаблицаИсторииХранилища[0].НомерВерсии);
	Для Сч = 1 По ТаблицаИсторииХранилища.Количество()-1 Цикл
		ЧислоВерсии = Число(ТаблицаИсторииХранилища[Сч].НомерВерсии);
		Если ЧислоВерсии > МаксимальнаяВерсия Тогда
			МаксимальнаяВерсия = ЧислоВерсии;
		КонецЕсли;
	КонецЦикла;

	Возврат МаксимальнаяВерсия;

КонецФункции

Процедура РазложитьМодулиПоНомеруВерсииХранилища1С(Знач КаталогРабочейКопии, Знач ПутьКХранилищу, Знач НомерВерсии, Знач Формат, Знач ПараметрыДоступаКХранилищу) Экспорт

	
	Если ИспользоватьTool1CD Тогда
		
		ФайлХранилища = Новый Файл(РаспаковщикКонфигурации.ПолучитьПутьКБазеДанныхХранилища(ПутьКХранилищу));

		Если ФайлХранилища.Существует() И ФайлХранилища.ЭтоФайл() И ВРег(ФайлХранилища.Расширение) = ".1CD" Тогда
			ВремКаталог = ВременныеФайлы.СоздатьКаталог();
			ФайлВерсии  = ИмяФайлаВыгрузкиВерсииХранилища(ВремКаталог, НомерВерсии);
			Лог.Отладка("Выгружаем версию хранилища в файл " + ФайлВерсии);
			Попытка
				ПоНомеруВерсииСохранитьКонфигурациюСредствамиTool1CD(ФайлХранилища.ПолноеИмя, ФайлВерсии, НомерВерсии);
				РазобратьФайлКонфигурации(ФайлВерсии, КаталогРабочейКопии, Формат);
			Исключение
				УдалитьВременныеФайлыПриНеобходимости(ВремКаталог);
				ВызватьИсключение;
			КонецПопытки;

			УдалитьВременныеФайлыПриНеобходимости(ВремКаталог);
		Иначе
			ВызватьИсключение "Что-то пошло не так "
		КонецЕсли
	Иначе

		РазобратьФайлКонфигурацииШтатнымиСредствами(ПутьКХранилищу, НомерВерсии, ПараметрыДоступаКХранилищу, КаталогРабочейКопии, Формат);

	КонецЕсли;

КонецПроцедуры

Процедура ПоНомеруВерсииСохранитьКонфигурациюСредствамиTool1CD(Знач ПутьКФайлуХранилища1С, Знач ВыходнойФайл, Знач НомерВерсииХранилища)

	Логирование.ПолучитьЛог("oscript.lib.tool1cd").УстановитьУровень(Лог.Уровень());
	Лог.Отладка("Получаем файл версии <"+НомерВерсииХранилища+"> из хранилища: " + ПутьКФайлуХранилища1С);
	ЧтениеХранилища = Новый ЧтениеХранилищаКонфигурации;
	ЧтениеХранилища.ВыгрузитьВерсиюКонфигурации(ПутьКФайлуХранилища1С, ВыходнойФайл, НомерВерсииХранилища);
	Лог.Отладка("Версия хранилища выгружена");

КонецПроцедуры

Функция ИмяФайлаВыгрузкиВерсииХранилища(Знач Каталог, Знач НомерВерсии)
	Возврат ОбъединитьПути(Каталог,  "v"+Строка(НомерВерсии) +".cf");
КонецФункции

Процедура ВывестиТекстФайла(Знач ИмяФайла, Знач Кодировка = Неопределено)

	Файл = Новый Файл(ИмяФайла);
	Если НЕ Файл.Существует() Тогда
		Возврат;
	КонецЕсли;

	Если Кодировка = Неопределено Тогда
		Кодировка = "utf-8";
	КонецЕсли;

	ЧТ = Новый ЧтениеТекста(ИмяФайла, Кодировка);
	СтрокаФайла = ЧТ.Прочитать();
	ЧТ.Закрыть();

	Лог.Информация(СтрокаФайла);

КонецПроцедуры

Функция СобратьКоманднуюСтроку(Знач ПереченьПараметров)

	СтрокаЗапуска = "";
	Для Каждого Параметр Из ПереченьПараметров Цикл

		СтрокаЗапуска = СтрокаЗапуска + " " + Параметр;

	КонецЦикла;

	Возврат СтрокаЗапуска;

КонецФункции

Функция ПолучитьТекстФайла(ИмяФайла, резТекстФайла = "")

	// проверим есть ли файл
	Файл = Новый Файл(ИмяФайла);
	Если НЕ Файл.Существует() Тогда
		Лог.Информация("Файл не существует."+ИмяФайла);
		Возврат Ложь;
	КонецЕсли;

	Кодировка = "utf-8";

	ФайлОтчета = Новый ЧтениеТекста(ИмяФайла, Кодировка);
	МассивСтрок = Новый Массив;

	Попытка
		Стр = "";
		Пока Стр <> Неопределено Цикл
			Стр = ФайлОтчета.ПрочитатьСтроку();
			МассивСтрок.Добавить(Стр);
		КонецЦикла;
		ФайлОтчета.Закрыть();
	Исключение
		Лог.Ошибка("При выводе файла возникла ошибка: %1", ОписаниеОшибки());
		Возврат Ложь;
	КонецПопытки;
	Если МассивСтрок.Количество() = 0 Тогда
		Лог.Информация("Файл пуст."+ИмяФайла);
		Возврат Ложь;
	КонецЕсли;

	Лог.Отладка("В файле найдено <"+МассивСтрок.Количество()+"> строк."+ИмяФайла);
	// вывести если строки не нашлись
	текстФайла = "+---/ "+ИмяФайла+" /-------------------------------";
	Для Инд = 0 По МассивСтрок.Количество()-1 Цикл
		текстФайла = текстФайла + Символы.ПС + "|"+МассивСтрок[Инд];
	КонецЦикла;
	текстФайла = текстФайла + Символы.ПС + "+-------------";
	резТекстФайла = текстФайла;

	Возврат Истина;
КонецФункции

Функция ОбернутьВКавычки(Знач Строка)
	Возврат """" + Строка + """";
КонецФункции


////////////////////////////////////////////////////////////////////////////////////////////////
// Общие функции

Функция ИмяФайлаАвторов() Экспорт
	Возврат "AUTHORS";
КонецФункции

Функция ИмяФайлаВерсииХранилища() Экспорт
	Возврат "VERSION"
КонецФункции

Функция ИмяФайлаСпискаЗадач() Экспорт
	Возврат "ListTasks.txt"
КонецФункции	

Процедура ЗаписатьФайлВерсийГит(Знач КаталогФайлаВерсий, Знач Версия = "") Экспорт

	ПутьКФайлуВерсий = ОбъединитьПути(КаталогФайлаВерсий, ИмяФайлаВерсииХранилища());
	Лог.Отладка("ПутьКФайлуВерсий =<"+ПутьКФайлуВерсий+">");
	Попытка
		Запись = Новый ЗаписьТекста(ПутьКФайлуВерсий, "utf-8");
		Запись.ЗаписатьСтроку("<?xml version=""1.0"" encoding=""UTF-8""?>");
		Запись.ЗаписатьСтроку("<VERSION>" + Версия + "</VERSION>");
		Запись.Закрыть();
	Исключение
		Если Запись <> Неопределено Тогда
			ОсвободитьОбъект(Запись);
		КонецЕсли;
		ВызватьИсключение;
	КонецПопытки;

КонецПроцедуры

Функция ПрочитатьФайлВерсийГит(Знач ПутьКФайлуВерсий)

	Перем Версия;

	Если Не Новый Файл(ПутьКФайлуВерсий).Существует() Тогда
		ВызватьИсключение "Файл с версией ГИТ <"+ПутьКФайлуВерсий+"> не существует";
	КонецЕсли;

	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.ОткрытьФайл(ПутьКФайлуВерсий);

	Пока ЧтениеXML.Прочитать() Цикл
		Если ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента И ЧтениеXML.Имя = "VERSION" Тогда

			Если Не ЧтениеXML.Прочитать() Тогда
				ВызватьИсключение "Чтение файла версий, у элемента Version нет текста";
			КонецЕсли;

			Если Не ЧтениеXML.ТипУзла = ТипУзлаXML.Текст Тогда
				ВызватьИсключение "Чтение файла версий, у элемента Version нет текста";
			КонецЕсли;

			Версия = ЧтениеXML.Значение;
			Лог.Отладка("Предыдущая версия из хранилища 1С: "+Версия);

			лРезультат = Истина;
			Прервать;
		КонецЕсли;

	КонецЦикла;

	ЧтениеXML.Закрыть();

	Возврат Версия;

КонецФункции

Функция ДобавитьПереименование(Знач Переименования, Знач Источник, Знач Приемник)

	СтрокаПереименования = Переименования.Добавить();
	СтрокаПереименования.Источник = Источник;
	СтрокаПереименования.Приемник = Приемник;

	Возврат СтрокаПереименования;

КонецФункции

Функция ПрочитатьФайлАвторовГитВТаблицуПользователей(Знач ПутьКФайлуАвторов) Экспорт

	Если НЕ ЗначениеЗаполнено(ПутьКФайлуАвторов) Тогда
		Возврат Неопределено;
	КонецЕсли;

	Файл = Новый Файл(ПутьКФайлуАвторов);
	Если Не Файл.Существует() Тогда
		Возврат НоваяТаблицаПользователейХранилища();
	КонецЕсли;

	Пользователи = НоваяТаблицаПользователейХранилища();

	Попытка
		ТекстовыйФайл = Новый ЧтениеТекста(ПутьКФайлуАвторов,"utf-8");
		СтрокаФайла = "";
		Пока СтрокаФайла <> Неопределено Цикл
			СтрокаФайла = ТекстовыйФайл.ПрочитатьСтроку();
			Индекс = Найти(СтрокаФайла, "=");
			Если Индекс > 0 Тогда

				Ключ = Лев(СтрокаФайла, Индекс-1);
				АвторПредставление = Сред(СтрокаФайла, Индекс+1);

				НоваяСтрока = Пользователи.Добавить();
				НоваяСтрока.ПредставлениеАвтора = АвторПредставление;
				НоваяСтрока.Автор = Ключ;
			КонецЕсли;
		КонецЦикла;

	Исключение
		Если ТекстовыйФайл <> Неопределено Тогда
			ОсвободитьОбъект(ТекстовыйФайл);
		КонецЕсли;
		ВызватьИсключение;
	КонецПопытки;

	Если ТекстовыйФайл <> Неопределено Тогда
		ОсвободитьОбъект(ТекстовыйФайл);
	КонецЕсли;

	Возврат Пользователи;

КонецФункции

Процедура УстановитьРежимУдаленияВременныхФайлов(ПарамУдалятьВременныеФайлы) Экспорт
	УдалятьВременныеФайлы = ПарамУдалятьВременныеФайлы;
КонецПроцедуры

Процедура УстановитьУровеньЛога(ПарамУровеньЛогирования) Экспорт
	Лог.УстановитьУровень(ПарамУровеньЛогирования);
КонецПроцедуры	

Процедура ПроверитьПараметрыДоступаКХранилищу(ПараметрыДоступаКХранилищу) Экспорт
	
	Если ПараметрыДоступаКХранилищу.ПользовательХранилища = Неопределено Тогда
		
		ВызватьИсключение "Не задан пользователь хранилища конфигурации.";
		
	КонецЕсли;
	
	Если ПараметрыДоступаКХранилищу.ПарольХранилища = Неопределено Тогда
	
		ПарольХранилища = "";
		
	КонецЕсли;
	
КонецПроцедуры // ПроверитьПараметрыДоступаКХранилищу

// Выполняет обновление конфигурации из хранилища, выгрузку конфигурации в файлы
// и распределение файлов по каталогам согласно иерархии метаданных.
//
Процедура РазобратьФайлКонфигурацииШтатнымиСредствами(Знач ПутьКХранилищу, Знач НомерВерсии, Знач ПараметрыДоступаКХранилищу, Знач ВыходнойКаталог, Знач Формат) Экспорт
	
	КаталогПлоскойВыгрузки = ВременныеФайлы.СоздатьКаталог();

	Если Не (Новый Файл(ВыходнойКаталог).Существует()) Тогда
		СоздатьКаталог(ВыходнойКаталог);
	КонецЕсли;

	КаталогВыгрузки = ?(ТолькоИзменения, ВыходнойКаталог, КаталогПлоскойВыгрузки);
	Попытка
		ВыгрузитьМодулиКонфигурацииОбновлениеИзХранилища(ПутьКХранилищу, НомерВерсии, ПараметрыДоступаКХранилищу, КаталогПлоскойВыгрузки, Формат);
		Если НЕ ТолькоИзменения Тогда
			РазложитьМодули1СПоПапкамСогласноИерархииМетаданных(КаталогПлоскойВыгрузки, ВыходнойКаталог, Формат);
		Иначе
			МассивФайлов = НайтиФайлы(КаталогВыгрузки, "*.bin", Истина);
			Для каждого Файл из МассивФайлов Цикл
				Если Нрег(Файл.Имя) = "form.bin" Тогда
					КаталогФормы = ОбъединитьПути(Файл.Путь, Файл.ИмяБезРасширения);
					СоздатьКаталог(КаталогФормы);
					ФС.ОбеспечитьПустойКаталог(КаталогФормы);
					РаспаковатьКонтейнерМетаданных(Файл.ПолноеИмя, КаталогФормы);
				КонецЕсли;
			КонецЦикла;

			Если Новый Файл(ОбъединитьПути(КаталогВыгрузки, "renames.txt")).Существует() Тогда
				УдалитьВременныеФайлыПриНеобходимости(ОбъединитьПути(КаталогВыгрузки, "renames.txt"));
			КонецЕсли;

		КонецЕсли;
	Исключение
		УдалитьВременныеФайлыПриНеобходимости(КаталогПлоскойВыгрузки);
		ВызватьИсключение;
	КонецПопытки;

КонецПроцедуры


// Выполняет штатную выгрузку конфигурации в файлы (средствами платформы 8.3) без загрузки конфигурации, но с обновлением на версию хранилища
//
Процедура ВыгрузитьМодулиКонфигурацииОбновлениеИзХранилища(Знач ПутьКХранилищу, Знач НомерВерсии, Знач ПараметрыДоступаКХранилищу, Знач КаталогПлоскойВыгрузки, Знач Формат) Экспорт
	
	Конфигуратор = ПолучитьМенеджерКонфигуратора();
	Если ВерсияПлатформы <> Неопределено Тогда
		Конфигуратор.ИспользоватьВерсиюПлатформы(ВерсияПлатформы);
	Иначе
		Конфигуратор.ИспользоватьВерсиюПлатформы("8.3");
	КонецЕсли;

	ЛогКонфигуратора = Логирование.ПолучитьЛог("oscript.lib.v8runner");
	ЛогКонфигуратора.УстановитьУровень(Лог.Уровень());
	
	ПользовательХранилища = ПараметрыДоступаКХранилищу.ПользовательХранилища;
	ПарольХранилища		  = ПараметрыДоступаКХранилищу.ПарольХранилища;

	Попытка

		ПараметрыЗапуска = Конфигуратор.ПолучитьПараметрыЗапуска();
		ПараметрыЗапуска.Добавить("/ConfigurationRepositoryUpdateCfg");
		ПараметрыЗапуска.Добавить("/ConfigurationRepositoryF """+ПутьКХранилищу+"""");
		
		ПараметрыЗапуска.Добавить("/ConfigurationRepositoryN """+ПользовательХранилища+"""");
		
		Если Не ПустаяСтрока(ПарольХранилища) Тогда
			ПараметрыЗапуска.Добавить("/ConfigurationRepositoryP """+ПарольХранилища+"""");
		КонецЕсли;

		ПараметрыЗапуска.Добавить("-v "+НомерВерсии);
		
		ПараметрыЗапуска.Добавить("-force");
		
		ВыполнитьКомандуКонфигуратора(Конфигуратор, ПараметрыЗапуска);

		//Конфигуратор.ОбновитьКонфигурациюБазыДанныхИзХранилищаНаВерсию(ПутьКХранилищу, ПользовательХранилища, ПарольХранилища, НомерВерсии);

	Исключение
		
		ТекстОшибки = Конфигуратор.ВыводКоманды();
		ВызватьИсключение ТекстОшибки;

	КонецПопытки;

	Если Не (Новый Файл(КаталогПлоскойВыгрузки).Существует()) Тогда
		СоздатьКаталог(КаталогПлоскойВыгрузки);
	КонецЕсли;

	МассивФайлов = НайтиФайлы(КаталогПлоскойВыгрузки, ПолучитьМаскуВсеФайлы());
	Если МассивФайлов.Количество() <> 0 Тогда
		ВызватьИсключение "В каталоге <"+КаталогПлоскойВыгрузки+"> не должно быть файлов";
	КонецЕсли;

	ПараметрыЗапуска = Конфигуратор.ПолучитьПараметрыЗапуска();
	ПараметрДампаКонфигурации = СтрШаблон("/DumpConfigToFiles ""%1"" -format %2", КаталогПлоскойВыгрузки, ТРег(Формат));
	ПараметрыЗапуска.Добавить(ПараметрДампаКонфигурации);

	ВыполнитьКомандуКонфигуратора(Конфигуратор, ПараметрыЗапуска);

КонецПроцедуры

///////////////////////////////////////////////////////////////////////////////////////////////
// Вспомогательные функции

// Удаляет временные файлы при необходимости
// Если передана пустая строка, то удаляются все зарегистрированные временные файлы
//
// Параметры:
//   ПутьКФайлу - Строка - полный путь файла или пустая строка
//
Процедура УдалитьВременныеФайлыПриНеобходимости(Знач ПутьКФайлу = "") Экспорт

	Если НЕ УдалятьВременныеФайлы Тогда
		Возврат;
	КонецЕсли;

	Если ПутьКФайлу = "" Тогда
		ВременныеФайлы.Удалить();
	Иначе
		ВременныеФайлы.УдалитьФайл(ПутьКФайлу);
	КонецЕсли;

КонецПроцедуры

Функция ДатаPOSIX(Знач Дата)

	Возврат "" + Год(Дата) + "-" + ФорматДвузначноеЧисло(Месяц(Дата)) + "-" + ФорматДвузначноеЧисло(День(Дата)) + " "
			+ ФорматДвузначноеЧисло(Час(Дата)) + ":" + ФорматДвузначноеЧисло(Минута(Дата)) + ":" + ФорматДвузначноеЧисло(Секунда(Дата));

КонецФункции

Процедура ДополнитьМассив(Знач Приемник, Знач Источник)

	Для Каждого Элемент Из Источник Цикл
		Приемник.Добавить(Элемент);
	КонецЦикла;

КонецПроцедуры

Процедура УбедитьсяЧтоФайлИлиКаталогСуществует(Знач Путь)

	Файл = Новый Файл(Путь);
	Если Не Файл.Существует() Тогда
		ВызватьИсключение СтроковыеФункции.ПодставитьПараметрыВСтроку("Файл <%1> должен существовать", Путь);
	КонецЕсли;

КонецПроцедуры

Функция ЗапуститьПриложениеИДождатьсяЗавершения(Знач СтрокаЗапуска, Знач ТекущийКаталог = "\.")

	рез = -1;
	Если НЕ ЭтоWindows И ТекущийКаталог = "\." Тогда
		ТекущийКаталог = "./";
	КонецЕсли;

	Попытка
		КодВозврата = "";
		ЗапуститьПриложение(СтрокаЗапуска, ТекущийКаталог, Истина, КодВозврата);
		рез = КодВозврата;
	Исключение
		// Для x64 ОС
		Если ЭтоWindows Тогда
			СтрокаЗапуска = "%windir%\Sysnative\" + СтрокаЗапуска;
			КодВозврата = "";
			ЗапуститьПриложение(СтрокаЗапуска, ТекущийКаталог, Истина, КодВозврата);
			рез = КодВозврата;
		КонецЕсли;
	КонецПопытки;

	Возврат рез;

КонецФункции // ЗапуститьПриложениеИДождатьсяЗавершения()

Процедура ЗавершитьПроцесс_TGitCache_exe()
	Если ЭтоWindows Тогда
		СтрокаКоманды = "taskkill /im TGitCache.exe  /T /F";
		Лог.Отладка("ЗавершитьПроцесс_TGitCache_exe: команда "+ СтрокаКоманды);

		ЗапуститьПриложениеИДождатьсяЗавершения(СтрокаКоманды);
	КонецЕсли;
КонецПроцедуры

Функция ФорматДвузначноеЧисло(ЗначениеЧисло)
	С = Строка(ЗначениеЧисло);
	Если СтрДлина(С) < 2 Тогда
		С = "0" + С;
	КонецЕсли;

	Возврат С;
КонецФункции

Функция ДоменПочтыДляGit()
	Возврат ?(ДоменПочтыДляGitПоУмолчанию = Неопределено, "localhost", ДоменПочтыДляGitПоУмолчанию);
КонецФункции

Процедура УстановитьКоличествоЦикловОжиданияЛицензииПоУмолчанию(КоличествоЦиклов) Экспорт
	КоличествоЦикловОжиданияЛицензииПоУмолчанию = КоличествоЦиклов;
КонецПроцедуры

Функция ПолучитьКоличествоЦикловОжиданияЛицензииПоУмолчанию() Экспорт
	Возврат КоличествоЦикловОжиданияЛицензииПоУмолчанию;
КонецФункции

//////////////////////////////////////////////////////////////////////////////////////////////
СистемнаяИнформация = Новый СистемнаяИнформация;
ЭтоWindows = Найти(НРег(СистемнаяИнформация.ВерсияОС), "windows") > 0;

Лог = Логирование.ПолучитьЛог("oscript.app.gitsync");
	
ДоменПочтыДляGitПоУмолчанию = "localhost";
УдалятьВременныеФайлы = Ложь;
КоличествоЦикловОжиданияЛицензииПоУмолчанию = 1;
ТолькоИзменения = Ложь;
МинимальнаяРазницаМеждуКоммитамиНовогоХранилища = 10;
ИспользоватьTool1CD = Истина;
