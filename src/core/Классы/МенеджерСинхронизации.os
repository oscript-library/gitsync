#Использовать logos
#Использовать tempfiles
#Использовать v8runner
#Использовать v8storage
#Использовать strings
#Использовать 1commands
#Использовать gitrunner
#Использовать fs
#Использовать "./internal"
#Использовать "./internal/bindata"

Перем Лог; // Объект, для логирования
Перем ЭтоWindows; // Булево, призная операционной системы WINDOWS
Перем УдалятьВременныеФайлы; // Булево, признак удаления временных файлов
Перем КоличествоЦикловОжиданияЛицензииПоУмолчанию; // Число, количество попыток получения лицензии

Перем РабочийКаталогСохр; // Строка, рабочий каталог для класса <ГитРепозиторий>
Перем ГитРепозиторийСохр; // Объект.ГитРепозиторий
// Определяем мин количество коммитов между разницей версии уже в git и в хранилище
// для случаев, когда пересоздали хранилище и в гите находится версия 1234, а в хранилище 4,
// тогда вызываем исключение если разница в коммитах больше чем на эту величину.
Перем МинимальнаяРазницаМеждуКоммитамиНовогоХранилища;
Перем ОбработчикПодписок; // Объект.МенеджерПодписок

Перем ХранилищеКонфигурации; // Объект.МенеджерХранилищаКонфигурации
Перем АвторизацияВХранилище; // Структура ключи <Пользователь>, <ПарольПользователя>
Перем РабочийКонфигуратор; // Объект.УправлениеКонфигуратором
Перем ПутьКИсполняемомуФайлуGit; // Строка, полный путь к исполняемому файлу git
Перем ИмяРасширения; // Строка, Имя расширения для синхронизации
Перем КонтекстВыполнения; // Структура, Ключи СтрокаСоединения, Пользователь, Пароль

///////////////////////////////////////////////////////////////////////////////////////////////
// ПРОГРАММНЫЙ ИНТЕРФЕЙС

Перем ДоменПочтыДляGitПоУмолчанию Экспорт; // Строка, домен пользователей по умолчанию
Перем ТекущаяВерсияПлатформы Экспорт; // Строка, используемая версия 1С.Предприятие
Перем ТекущийПутьКПлатформе Экспорт; // Строка, путь к исполняемому файлу платформы 1С.Предприятие

#Область Публичное_API

// Устанавливает параметры авторизации в хранилище конфигурации 1С
//
// Параметры:
//   Пользователь - Строка - пользователь хранилища конфигурации 1С
//   Пароль - Строка - пароль пользователя хранилища конфигурации 1С
//
// Возвращаемое значение:
//   Объект.МенеджерСинхронизации - ссылка на текущий объект класса <МенеджерСинхронизации>
//
Функция АвторизацияВХранилищеКонфигурации(Знач Пользователь, Знач Пароль) Экспорт
	
	Лог.Отладка("Установлена авторизация в хранилище пользователь <%1>, пароль <%2>", Пользователь, Пароль);
	АвторизацияВХранилище.Вставить("ПользовательХранилища" , Пользователь);
	АвторизацияВХранилище.Вставить("ПарольХранилища", Пароль);
	
	Возврат ЭтотОбъект;
	
КонецФункции

// Устанавливает признак необходимости удаления временных файлов
//
// Параметры:
//   ПарамУдалятьВременныеФайлы - Булево - признак необходимости удаления временных файлов
//
// Возвращаемое значение:
//   Объект.МенеджерСинхронизации - ссылка на текущий объект класса <МенеджерСинхронизации>
//
Функция РежимУдаленияВременныхФайлов(Знач ПарамУдалятьВременныеФайлы) Экспорт
	
	УдалятьВременныеФайлы = ПарамУдалятьВременныеФайлы;
	Возврат ЭтотОбъект;
	
КонецФункции

// Устанавливает имя расширения для синхронизации хранилища
//
// Параметры:
//   ПИмяРасширения - Строка - имя расширения для выгрузки
//
// Возвращаемое значение:
//   Объект.МенеджерСинхронизации - ссылка на текущий объект класса <МенеджерСинхронизации>
//
Функция ИмяРасширения(Знач ПИмяРасширения) Экспорт
	
	ИмяРасширения = ПИмяРасширения;
	Возврат ЭтотОбъект;
	
КонецФункции

// Получает имя установленного расширения для синхронизации хранилища
//
//
// Возвращаемое значение:
//   ИмяРасширения - Строка - имя расширения для выгрузки
//
Функция ПолучитьИмяРасширения() Экспорт
	Возврат ИмяРасширения	
КонецФункции

// Устанавливает набор подписчиков
//
// Параметры:
//   ПИндексПодписчиков - Соответствие - набор подписчиков
//                                        * ключ - Строка - имя подписчика
//                                        * значение - Объект - ссылка на произвольный объект
//   ППараметрыПодписок - Соответствие - набор параметров для подписчиков
// Возвращаемое значение:
//   Объект.МенеджерСинхронизации - ссылка на текущий объект класса <МенеджерСинхронизации>
//
Функция ПодпискиНаСобытия(Знач ПИндексПодписчиков, Знач ППараметрыПодписок = Неопределено) Экспорт
	
	УстановитьОбработчикПодписок(ПИндексПодписчиков);

	Если Не ППараметрыПодписок = Неопределено Тогда
		ПараметрыПодписокНаСобытия(ППараметрыПодписок);
	КонецЕсли;

	Возврат ЭтотОбъект;
	
КонецФункции

// Устанавливает параметров для подписчиков
//
// Параметры:
//   НовыеПараметры - Соответствие - набор значений передаваемых подписчикам
//
// Возвращаемое значение:
//   Объект.МенеджерСинхронизации - ссылка на текущий объект класса <МенеджерСинхронизации>
//
Функция ПараметрыПодписокНаСобытия(Знач НовыеПараметры) Экспорт
	
	ПараметрыПодписчиков = Новый ПараметрыПодписчиков(НовыеПараметры);
	
	ОбработчикПодписок.ПриПолученииПараметров(ПараметрыПодписчиков);
	Возврат ЭтотОбъект;
	
КонецФункции

// Устанавливает количество циклов ожидания лицензий
//
// Параметры:
//   КоличествоЦиклов - Число - количество циклов ожидания лицензии
//
// Возвращаемое значение:
//   Объект.МенеджерСинхронизации - ссылка на текущий объект класса <МенеджерСинхронизации>
//
Функция ЦикловОжиданияЛицензии(Знач КоличествоЦиклов) Экспорт
	
	КоличествоЦикловОжиданияЛицензииПоУмолчанию = КоличествоЦиклов;
	Возврат ЭтотОбъект;
	
КонецФункции

// Устанавливает уровень вывода логов
//
// Параметры:
//   НовыйУровеньЛога - Строка - уровень вывода лога
//
// Возвращаемое значение:
//   Объект.МенеджерСинхронизации - ссылка на текущий объект класса <МенеджерСинхронизации>
//
Функция УровеньЛога(Знач НовыйУровеньЛога) Экспорт
	
	Лог.УстановитьУровень(НовыйУровеньЛога);
	Возврат ЭтотОбъект;
	
КонецФункции

// Устанавливает домен для почты по умолчанию
//
// Параметры:
//   НовыйДоменПочтыДляGit - Строка - новый домен для почты по умолчанию
//
// Возвращаемое значение:
//   Объект.МенеджерСинхронизации - ссылка на текущий объект класса <МенеджерСинхронизации>
//
Функция ДоменПочтыПоУмолчанию(Знач НовыйДоменПочтыДляGit) Экспорт
	
	ДоменПочтыДляGitПоУмолчанию = НовыйДоменПочтыДляGit;
	Возврат ЭтотОбъект;
	
КонецФункции

// Устанавливает версию платформы 1С
//
// Параметры:
//   НоваяВерсияПлатформы - Строка - версия платформы 1С используемой для работы
//
// Возвращаемое значение:
//   Объект.МенеджерСинхронизации - ссылка на текущий объект класса <МенеджерСинхронизации>
//
Функция ВерсияПлатформы(Знач НоваяВерсияПлатформы) Экспорт
	
	ТекущаяВерсияПлатформы = НоваяВерсияПлатформы;
	Возврат ЭтотОбъект;
	
КонецФункции

// Устанавливает версию платформы 1С
//
// Параметры:
//   НовыйПутьКПлатформе - Строка - путь к исполняемому файлу платформы 1С.Предприятие
//
// Возвращаемое значение:
//   Объект.МенеджерСинхронизации - ссылка на текущий объект класса <МенеджерСинхронизации>
//
Функция ПутьКПлатформе(Знач НовыйПутьКПлатформе) Экспорт
	
	ТекущийПутьКПлатформе = НовыйПутьКПлатформе;
	Возврат ЭтотОбъект;
	
КонецФункции

// Устанавливает путь к исполняемому файлу git
//
// Параметры:
//   НовыйПутьКИсполняемомуФайлуГит - Строка - путь к исполняемому файлу git
//
// Возвращаемое значение:
//   Объект.МенеджерСинхронизации - ссылка на текущий объект класса <МенеджерСинхронизации>
//
Функция ИсполняемыйФайлГит(Знач НовыйПутьКИсполняемомуФайлуГит) Экспорт
	
	ПутьКИсполняемомуФайлуGit = НовыйПутьКИсполняемомуФайлуГит;
	Возврат ЭтотОбъект;
	
КонецФункции

// Устанавливает контекст выполнения синхронизации
//
// Параметры:
//   СтрокаСоединения - Строка - строка соединения с информационной базой
//   Пользователь - Строка - пользователь информационной базы
//   Пароль - Строка - пароль информационной базы
//
// Возвращаемое значение:
//   Объект.МенеджерСинхронизации - ссылка на текущий объект класса <МенеджерСинхронизации>
//
Функция УстановитьКонтекст(Знач СтрокаСоединения, Знач Пользователь, Знач Пароль) Экспорт

	КонтекстВыполнения.СтрокаСоединения = СтрокаСоединения;
	КонтекстВыполнения.Пользователь = Пользователь;
	КонтекстВыполнения.Пароль = Пароль;

	ПоказатьКонтекстВРежимеОтладки();

	Возврат ЭтотОбъект;
КонецФункции

// Основная функция синхронизации.
// Перемещает в git набор коммитов хранилища 1С
//
// Параметры:
//   КаталогРабочейКопии - Строка - путь к каталогу рабочей копии
//   ПутьКХранилищу - Строка - путь к хранилищу конфигурации
//
Процедура Синхронизировать(Знач КаталогРабочейКопии, Знач ПутьКХранилищу) Экспорт
	
	ОбработчикПодписок.ПередНачаломВыполнения(ПутьКХранилищу, КаталогРабочейКопии);
	
	Лог.Информация("Начата синхронизация с git");
	
	РабочийКонфигуратор = ПолучитьУправлениеКонфигуратором();
	
	ХранилищеКонфигурации = ПолучитьХранилищеКонфигурации(ПутьКХранилищу);

	ТекущаяВерсия = НомерСинхронизированнойВерсии(КаталогРабочейКопии);
	
	ТаблицаИсторииХранилища = ПрочитатьИзХранилищаИсториюКоммитовСАвторами(ПутьКХранилищу, ТекущаяВерсия);
	
	ДополнитьТаблицуХранилищаИнформациейОСигнатуреПользователяВГит(ТаблицаИсторииХранилища, КаталогРабочейКопии);
		
	Лог.Информация("Номер синхронизированной версии: " + ТекущаяВерсия);
	СледующаяВерсия = ТекущаяВерсия + 1;
	
	МаксимальнаяВерсияДляРазбора = ОпределитьМаксимальнуюВерсиюВХранилище(ТаблицаИсторииХранилища);
	Лог.Информация("Номер последней версии в хранилище: " + МаксимальнаяВерсияДляРазбора);
	
	Если СледующаяВерсия > МаксимальнаяВерсияДляРазбора
		И СледующаяВерсия - МаксимальнаяВерсияДляРазбора > МинимальнаяРазницаМеждуКоммитамиНовогоХранилища Тогда
		
		Лог.Ошибка("Несоответствие версий хранилища 1С и версию в репозитории Git.
		|Возможно, сократили/обрезали хранилище.
		|Для продолжения синхронизации измените файл VERSIONS в корне репозитория Git,
		|Исправьте версию %1 на правильную версию <= версии в хранилище %2", ТекущаяВерсия, МаксимальнаяВерсияДляРазбора);
		
		ВызватьИсключение СтрШаблон("Версия git %1 больше версии хранилища %2 на %3",
									ТекущаяВерсия,
									МаксимальнаяВерсияДляРазбора,
									СледующаяВерсия - МаксимальнаяВерсияДляРазбора);
	КонецЕсли;
	
	ОбработчикПодписок.ПередНачаломЦиклаОбработкиВерсий(ТаблицаИсторииХранилища,
														ТекущаяВерсия,
														СледующаяВерсия,
														МаксимальнаяВерсияДляРазбора);
	
	Пока СледующаяВерсия <= МаксимальнаяВерсияДляРазбора Цикл
		
		СтрокаВерсии = ТаблицаИсторииХранилища.Найти(СледующаяВерсия, "НомерВерсии");
		Если СтрокаВерсии <> Неопределено Тогда
			
			ОбработчикПодписок.ПередОбработкойВерсииХранилища(СтрокаВерсии, СледующаяВерсия);
			
			Попытка
				Лог.Информация("Получаем исходники для версии " + СледующаяВерсия + ", " + ТекущаяДата());
				
				ОбработчикПодписок.ПриОбработкеВерсииХранилища(СтрокаВерсии, СледующаяВерсия);
				
				ВыгрузитьВерсиюХранилищаКонфигурацииВИсходники(КаталогРабочейКопии, ПутьКХранилищу, СледующаяВерсия);
				
				Лог.Отладка("Фиксируем в файле VERSION версию " + СледующаяВерсия);
				ЗаписатьФайлВерсийГит(КаталогРабочейКопии, СледующаяВерсия);
				ВыполнитьКоммитГит(КаталогРабочейКопии,
									СтрокаВерсии.Комментарий,
									СтрокаВерсии.ПредставлениеАвтора,
									СтрокаВерсии.Дата);
									
			Исключение
				Лог.Отладка("Откатываем файл VERSION после ошибки");
				ЗаписатьФайлВерсийГит(КаталогРабочейКопии, ТекущаяВерсия);
				ВызватьИсключение;
			КонецПопытки;
			
			ТекущаяВерсия = СледующаяВерсия;
			ОбработчикПодписок.ПослеОбработкиВерсииХранилища(СтрокаВерсии, ТекущаяВерсия);
			
		КонецЕсли;
		
		СледующаяВерсия = СледующаяВерсия + 1;
		
	КонецЦикла;
	
	ЗавершитьПроцесс_TGitCache_exe();
	
	ОбработчикПодписок.ПослеОкончанияВыполнения(ПутьКХранилищу, КаталогРабочейКопии);
	
	УдалитьВременныеФайлыПриНеобходимости();
	
	Лог.Информация("Завершена синхронизации с git");
	
КонецПроцедуры

#КонецОбласти

#Область Функциональность_обработки_версии_хранилища_конфигурации

// Процедура выполняет выгрузку версии хранилища 1с в исходники
//
// Параметры:
//   КаталогРабочейКопии - Строка - Путь к каталогу рабочей копии git
//   ПутьКХранилищу - Строка - Путь к хранилищу 1С
//   НомерВерсии - Число - номер выгружаемой версии
//
Процедура ВыгрузитьВерсиюХранилищаКонфигурацииВИсходники(Знач КаталогРабочейКопии,
														Знач ПутьКХранилищу,
														Знач НомерВерсии) Экспорт
	
	Конфигуратор = ПолучитьРабочийКонфигуратор();
	
	ОбработчикПодписок.ПередНачаломВыгрузкиВерсииХранилищаКонфигурации(Конфигуратор,
																		КаталогРабочейКопии,
																		ПутьКХранилищу,
																		НомерВерсии);
	
	ОбработчикПодписок.ПередЗагрузкойВерсииХранилищаКонфигурации(Конфигуратор,
																КаталогРабочейКопии,
																ПутьКХранилищу,
																НомерВерсии);
	
	ЗагрузитьВерсиюХранилищаВКонфигурацию(Конфигуратор, КаталогРабочейКопии, ПутьКХранилищу, НомерВерсии);
	
	КаталогВыгрузки = ВременныеФайлы.СоздатьКаталог();
	
	Лог.Отладка("Каталог выгрузки <%1> для версии <%2>", КаталогВыгрузки, НомерВерсии);
	
	ОбработчикПодписок.ПередВыгрузкойКонфигурациюВИсходники(Конфигуратор,
															КаталогРабочейКопии,
															КаталогВыгрузки,
															ПутьКХранилищу,
															НомерВерсии);
	
	ВыгрузитьКонфигурациюВИсходники(Конфигуратор, КаталогВыгрузки);
	
	ОбработчикПодписок.ПередОчисткойКаталогаРабочейКопии(Конфигуратор,
														КаталогРабочейКопии,
														КаталогВыгрузки,
														ПутьКХранилищу,
														НомерВерсии);
	
	ОчиститьКаталогРабочейКопии(КаталогРабочейКопии);
	
	ОбработчикПодписок.ПередПеремещениемВКаталогРабочейКопии(Конфигуратор,
															КаталогРабочейКопии,
															КаталогВыгрузки,
															ПутьКХранилищу,
															НомерВерсии);
	
	ПереместитьВКаталогРабочейКопии(КаталогРабочейКопии, КаталогВыгрузки);
	
	ОбработчикПодписок.ПослеОкончанияВыгрузкиВерсииХранилищаКонфигурации(Конфигуратор,
																		КаталогРабочейКопии,
																		ПутьКХранилищу,
																		НомерВерсии);
	
	УдалитьВременныеФайлыПриНеобходимости(КаталогВыгрузки);
	
КонецПроцедуры

#КонецОбласти

#Область Функциональность_загрузки_версии_из_хранилища

// Выполняет загрузку версии конфигурации из хранилища конфигурации
//
// Параметры:
//   Конфигуратор - Объект.УправлениеКонфигуратором - инициализированный класс <УправлениеКонфигуратором>
//   КаталогРабочейКопии - Строка - полный путь к рабочему каталогу копии
//   ПутьКХранилищу - Строка - полный путь к хранилищу конфигурации
//   НомерВерсии - Число - номер выгружаемой версии
//
Процедура ЗагрузитьВерсиюХранилищаВКонфигурацию(Знач Конфигуратор,
												Знач КаталогРабочейКопии,
												Знач ПутьКХранилищу,
												Знач НомерВерсии) Экспорт
	СтандартнаяОбработка = Истина;
	
	ОбработчикПодписок.ПриЗагрузкеВерсииХранилищаВКонфигурацию(Конфигуратор,
																КаталогРабочейКопии,
																ПутьКХранилищу,
																НомерВерсии,
																СтандартнаяОбработка);
	
	Если СтандартнаяОбработка Тогда
		
		ЗагрузитьВерсиюХранилищаВКонфигурациюСтандартнаяОбработка(Конфигуратор,
		НомерВерсии);
		
	КонецЕсли;
	
	ОбработчикПодписок.ПослеЗагрузкиВерсииХранилищаВКонфигурацию(Конфигуратор,
	КаталогРабочейКопии,
	ПутьКХранилищу,
	НомерВерсии);
	
КонецПроцедуры

// Стандартная обработка загрузки версии конфигурации из хранилища конфигурации
//
// Параметры:
//   Конфигуратор - Объект.УправлениеКонфигуратором - инициализированный класс <УправлениеКонфигуратором>
//   НомерВерсии - Число - номер выгружаемой версии
//
Процедура ЗагрузитьВерсиюХранилищаВКонфигурациюСтандартнаяОбработка(Конфигуратор,
	Знач НомерВерсии)
	
	ХранилищеКонфигурации.УстановитьУправлениеКонфигуратором(Конфигуратор);
	
	КоличествоЦикловОжиданияЛицензии = ПолучитьКоличествоЦикловОжиданияЛицензииПоУмолчанию();
	
	Пока КоличествоЦикловОжиданияЛицензии >= 0 Цикл
		Попытка
			
			ХранилищеКонфигурации.ОбновитьКонфигурациюНаВерсию(НомерВерсии);
			Прервать;
			
		Исключение
			// проверим текст ошибки, если текст содержит информацию о необходимости конвертировать
			// тогда выполним конвертацию и повторно попытаемся загрузить файл
			ТекстОшибки = ХранилищеКонфигурации.ПолучитьВыводКоманды();
			Если Найти(ВРег(ТекстОшибки), Врег("Не обнаружено свободной лицензии!")) 
				ИЛИ Найти(ВРег(ТекстОшибки), Врег("Не найдена лицензия.")) Тогда
				
				ПериодОжидания = 10000;
				Лог.Ошибка(ТекстОшибки);
				Лог.Информация("Повторное подключение через 10 сек. Осталось попыток: <%1>", КоличествоЦикловОжиданияЛицензии);
				Приостановить(ПериодОжидания);
				
			Иначе
				
				ВызватьИсключение ТекстОшибки;
				
			КонецЕсли;
			
		КонецПопытки;
		
		Если ПолучитьКоличествоЦикловОжиданияЛицензииПоУмолчанию() <> 0 Тогда
			КоличествоЦикловОжиданияЛицензии = КоличествоЦикловОжиданияЛицензии - 1;
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

#Область Функциональность_выгрузки_конфигурации_в_исходники

// Выполняет выгрузку версии конфигурации в исходники (стандартная обработка внутри)
//
// Параметры:
//   Конфигуратор - Объект.УправлениеКонфигуратором - инициализированный класс <УправлениеКонфигуратором>
//   КаталогВыгрузки - Строка - полный путь к временноиу каталогу выгрузки
//
Процедура ВыгрузитьКонфигурациюВИсходники(Знач Конфигуратор, Знач КаталогВыгрузки) Экспорт
	
	СтандартнаяОбработка = Истина;
	
	ОбработчикПодписок.ПриВыгрузкеКонфигурациюВИсходники(Конфигуратор, КаталогВыгрузки, СтандартнаяОбработка);
	
	Если СтандартнаяОбработка Тогда

		Попытка
		
			Если НЕ ПустаяСтрока(ИмяРасширения) Тогда
				Конфигуратор.ВыгрузитьРасширениеВФайлы(КаталогВыгрузки, ИмяРасширения);
			Иначе
				Конфигуратор.ВыгрузитьКонфигурациюВФайлы(КаталогВыгрузки);
			КонецЕсли;
		
		Исключение
			ОписаниеОшибки = ОписаниеОшибки();
			Если Не ЭтоПропускаемаяОшибка(ОписаниеОшибки) Тогда
				УдалитьВременныеФайлыПриНеобходимости(Конфигуратор.КаталогСборки());
				Лог.Ошибка("Невозможно выгрузить конфигурацию в файлы. Ошибка:" + ОписаниеОшибки);
				ВызватьИсключение;
			КонецЕсли;
		КонецПопытки;

  	КонецЕсли;
	
	ОбработчикПодписок.ПослеВыгрузкиКонфигурациюВИсходники(Конфигуратор, КаталогВыгрузки);
	
КонецПроцедуры

#КонецОбласти

#Область Функциональность_очистки_каталога_рабочей_копии

// Выполняет очистку каталога рабочей копии
//
// Параметры:
//   КаталогРабочейКопии - Строка - полный путь к рабочему каталогу копии
//
Процедура ОчиститьКаталогРабочейКопии(Знач КаталогРабочейКопии) Экспорт
	
	СтандартнаяОбработка = Истина;
	
	СоответствиеИменФайловДляПропуска = Новый Соответствие;
	СоответствиеИменФайловДляПропуска.Вставить(".git", Истина);
	СоответствиеИменФайловДляПропуска.Вставить(ИмяФайлаАвторов(), Истина); // Соответствие авторов и транслитерации.
	СоответствиеИменФайловДляПропуска.Вставить(ИмяФайлаВерсииХранилища(), Истина); // Номер версии, может использоватся для синхронизации с хранилищем.
	
	ОбработчикПодписок.ПриОчисткеКаталогаРабочейКопии(КаталогРабочейКопии,
														СоответствиеИменФайловДляПропуска,
														СтандартнаяОбработка);
	
	Если СтандартнаяОбработка Тогда
		
		ОчиститьКаталогРабочейКопииСтандартнаяОбработка(КаталогРабочейКопии, СоответствиеИменФайловДляПропуска);
		
	КонецЕсли;
	
	ОбработчикПодписок.ПослеОчисткиКаталогаРабочейКопии(КаталогРабочейКопии, СоответствиеИменФайловДляПропуска);
	
КонецПроцедуры

// Стандартная обработка очистки каталога рабочей копии
//
// Параметры:
//   КаталогРабочейКопии - Строка - полный путь к рабочему каталогу копии
//   СоответствиеИменФайловДляПропуска - Соответствие - ключи имен файлов для пропуска при очистки каталога
//
Процедура ОчиститьКаталогРабочейКопииСтандартнаяОбработка(Знач КаталогРабочейКопии, СоответствиеИменФайловДляПропуска)
	
	ЕстьОшибкаУдаления = Ложь;
	КоличествоПопыток = 2;
	Для НомерПопытки = 1 По КоличествоПопыток Цикл
		МассивФайлов = НайтиФайлы(КаталогРабочейКопии, ПолучитьМаскуВсеФайлы());
		Если МассивФайлов.Количество() = 0 Тогда
			Прервать;
		КонецЕсли;
		
		Для Каждого ЭлементМассива Из МассивФайлов Цикл
			Если СоответствиеИменФайловДляПропуска[ЭлементМассива.Имя] = Истина Тогда
				Продолжить;
			КонецЕсли;
			
			Попытка
				УдалитьФайлы(ЭлементМассива.ПолноеИмя);
			Исключение
				ЕстьОшибкаУдаления = Истина;
				Если НомерПопытки = КоличествоПопыток Тогда
					ВызватьИсключение;
				КонецЕсли;
			КонецПопытки;
		КонецЦикла;
		
		Если Не ЕстьОшибкаУдаления Тогда
			Прервать;
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

#Область Функциональность_перемещения_файлов_в_каталог_рабочей_копии

// Выполняет перемещение файлов в каталог рабочей копии
//
// Параметры:
//   КаталогРабочейКопии - Строка - полный путь к рабочему каталогу копии
//   КаталогВыгрузки - Строка - полный путь к каталогу выгрузки
//
Процедура ПереместитьВКаталогРабочейКопии(Знач КаталогРабочейКопии, Знач КаталогВыгрузки) Экспорт
	
	СтандартнаяОбработка = Истина;
	
	ОбработчикПодписок.ПриПеремещенииВКаталогРабочейКопии(КаталогРабочейКопии,
	КаталогВыгрузки,
	СтандартнаяОбработка);
	
	Если СтандартнаяОбработка Тогда
		
		ПереместитьВКаталогРабочейКопииСтандартнаяОбработка(КаталогРабочейКопии,
															КаталогВыгрузки);
		
	КонецЕсли;
	
	ОбработчикПодписок.ПослеПеремещенияВКаталогРабочейКопии(КаталогРабочейКопии,
	КаталогВыгрузки);
	
КонецПроцедуры

// Стандартная обработка перемещения файлов в каталог рабочей копии
//
// Параметры:
//   КаталогРабочейКопии - Строка - полный путь к рабочему каталогу копии
//   КаталогВыгрузки - Строка - полный путь к каталогу выгрузки
//
Процедура ПереместитьВКаталогРабочейКопииСтандартнаяОбработка(Знач КаталогРабочейКопии,
															Знач КаталогВыгрузки)
	
	СписокФайлов = НайтиФайлы(КаталогВыгрузки, ПолучитьМаскуВсеФайлы(), Истина);
	Лог.Отладка("Найдено файлов выгрузки: %1 шт.", СписокФайлов.Количество());
	Лог.Отладка("КаталогРабочейКопии: %1 ", КаталогРабочейКопии);
	Для Каждого Файл Из СписокФайлов Цикл
		
		КорневойКаталог = КаталогВыгрузки;
		Если НЕ СтрЗаканчиваетсяНа(КорневойКаталог, ПолучитьРазделительПути()) Тогда
			КорневойКаталог = КорневойКаталог + ПолучитьРазделительПути();
		КонецЕсли;
		
		ИмяНовогоФайла = СтрЗаменить(Файл.ПолноеИмя, КорневойКаталог, "");
		
		Если Файл.ЭтоКаталог() Тогда
			
			ИмяКаталога = ОбъединитьПути(КаталогРабочейКопии, ИмяНовогоФайла);
			ФайлКаталога = Новый Файл(ИмяКаталога);
			Если НЕ ФайлКаталога.Существует() Тогда
				СоздатьКаталог(ФайлКаталога.ПолноеИмя);
			КонецЕсли;
			
			Продолжить;
			
		КонецЕсли;
		
		НовыйФайл = Новый Файл(ОбъединитьПути(КаталогРабочейКопии, ИмяНовогоФайла));
		НовыйКаталог = Новый Файл(НовыйФайл.Путь);
		Если НЕ НовыйКаталог.Существует() Тогда
			СоздатьКаталог(НовыйКаталог.ПолноеИмя);
		КонецЕсли;
		
		КопироватьФайл(Файл.ПолноеИмя, НовыйФайл.ПолноеИмя);
		
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

#Область Функциональность_работы_с_конфигуратором

// Подготавливает управление конфигуратором для выполнения операций
//
// Возвращаемое значение:
//   Объект.УправлениеКонфигуратором - инициализированный класс <УправлениеКонфигуратором>
//
Функция ПолучитьРабочийКонфигуратор() Экспорт
	
	Если РабочийКонфигуратор = Неопределено Тогда
		
		РабочийКонфигуратор = ПолучитьУправлениеКонфигуратором();
		
	КонецЕсли;
	
	Возврат РабочийКонфигуратор;
	
КонецФункции

// Подготавливает управление конфигуратором для выполнения операций
//
// Возвращаемое значение:
//   Объект.УправлениеКонфигуратором - инициализированный класс <УправлениеКонфигуратором>
//
Функция ПолучитьУправлениеКонфигуратором() Экспорт
		
	УправлениеКонфигуратором = Новый УправлениеКонфигуратором;
	Логирование.ПолучитьЛог("oscript.lib.v8runner").УстановитьУровень(Лог.Уровень());
	КаталогСборки = ВременныеФайлы.СоздатьКаталог();
	УправлениеКонфигуратором.КаталогСборки(КаталогСборки);
	
	Если ЗначениеЗаполнено(КонтекстВыполнения.СтрокаСоединения) Тогда
		
		Лог.Отладка("Для синхронизации используется база <%1>", КонтекстВыполнения.СтрокаСоединения);
		УправлениеКонфигуратором.УстановитьКонтекст(КонтекстВыполнения.СтрокаСоединения, КонтекстВыполнения.Пользователь, КонтекстВыполнения.Пароль);

	КонецЕсли;

	Если ЗначениеЗаполнено(ТекущийПутьКПлатформе) Тогда
		
		Если Не ФС.ФайлСуществует(ТекущийПутьКПлатформе) Тогда
			
			ВызватьИсключение СтрШаблон("Исполняемый файл платформы 1С <%1> не найден", ТекущийПутьКПлатформе);
			
		КонецЕсли;
		
		УправлениеКонфигуратором.ПутьКПлатформе1С(ТекущийПутьКПлатформе);
		Лог.Информация("Используется путь к платформе 1С <%1>", ТекущийПутьКПлатформе);
	Иначе
		УправлениеКонфигуратором.ИспользоватьВерсиюПлатформы(ТекущаяВерсияПлатформы, РазрядностьПлатформы.x64x86);
		Лог.Отладка("Используется платформа 1С версии <%1>", ТекущаяВерсияПлатформы);
	КонецЕсли;
	
	Возврат УправлениеКонфигуратором;
	
КонецФункции

#КонецОбласти

#Область Функциональность_работы_с_ГитРепозиторием

// Подготавливает объект ГитРепозиторий для работы с git
//
// Параметры:
//   КаталогРабочейКопии - Строка - путь к каталогу рабочей копии git
//
// Возвращаемое значение:
//   Объект.ГитРепозиторий - подготовленный объект класса <ГитРепозиторий>
//
Функция ПолучитьГитРепозиторий(Знач КаталогРабочейКопии) Экспорт
	
	ФайлКаталога = Новый Файл(КаталогРабочейКопии);
	Если ФайлКаталога.ПолноеИмя = РабочийКаталогСохр Тогда
		ГитРепозиторий = ГитРепозиторийСохр;
	Иначе
		ГитРепозиторий = Новый ГитРепозиторий;
		ГитРепозиторий.УстановитьРабочийКаталог(КаталогРабочейКопии);
		ГитРепозиторий.УстановитьТихийРежимРаботы();
		
		Если ЗначениеЗаполнено(ПутьКИсполняемомуФайлуGit) Тогда
			ГитРепозиторий.УстановитьПутьКГит(ПутьКИсполняемомуФайлуGit);
		КонецЕсли;
		
		ГитРепозиторий.УстановитьНастройку("core.quotepath", "false", РежимУстановкиНастроекGit.Локально);
		ГитРепозиторий.УстановитьНастройку("merge.ours.driver", "true", РежимУстановкиНастроекGit.Локально);
		
		ГитРепозиторий.УстановитьНормальныйРежимРаботы();
		
		РабочийКаталогСохр = ФайлКаталога.ПолноеИмя;
		ГитРепозиторийСохр = ГитРепозиторий;
		
	КонецЕсли;
	
	Возврат ГитРепозиторий;
	
КонецФункции // ПолучитьГитРепозиторий()

// Выполняет фиксацию изменений в локальном каталоге git
//
// Параметры:
//   КаталогРабочейКопии - Строка - полный путь к рабочему каталогу копии
//   Комментарий - Строка - комментарий изменений при фиксации
//   Автор - Строка - автор изменений при фиксации
//   Дата - Дата - дата изменений фиксации
//
Процедура ВыполнитьКоммитГит(Знач КаталогРабочейКопии, Знач Комментарий, Знач Автор, Знач Дата = Неопределено) Экспорт
	
	ОбработчикПодписок.ПередКоммитом(КаталогРабочейКопии, Комментарий, Автор, Дата);
	
	Если Дата = Неопределено Тогда
		Дата = ТекущаяДата();
	КонецЕсли;
	
	АвторДляГит = Автор;
	
	Лог.Отладка("Автор коммита: %1", АвторДляГит);
	ДатаДляГит = ДатаPOSIX(Дата);
	Лог.Отладка("Дата коммита: %1", ДатаДляГит);
	ИмяФайлаКомментария = ПодготовитьФайлКоммита(Комментарий);
	
	ГитРепозиторий = ПолучитьГитРепозиторий(КаталогРабочейКопии);
	ПроиндексироватьОтслеживаемыеФайлы = Истина;
	// Выполнение индексации всех измененных файлов
	ОбработчикПодписок.ПриКоммите(ГитРепозиторий,
								Комментарий,
								ПроиндексироватьОтслеживаемыеФайлы,
								ИмяФайлаКомментария,
								АвторДляГит,
								ДатаДляГит,
								АвторДляГит,
								ДатаДляГит);
	
	ГитРепозиторий.ВыполнитьКоманду(СтрРазделить("add -A .", " "));
	ГитРепозиторий.Закоммитить(Комментарий,
							ПроиндексироватьОтслеживаемыеФайлы,
							ИмяФайлаКомментария,
							АвторДляГит,
							ДатаДляГит,
							АвторДляГит,
							ДатаДляГит);
	Лог.Отладка("Вывод команды Commit: %1", СокрЛП(ГитРепозиторий.ПолучитьВыводКоманды()));
	
	ОбработчикПодписок.ПослеКоммита(ГитРепозиторий, КаталогРабочейКопии);
	
	ЗавершитьПроцесс_TGitCache_exe();
	
КонецПроцедуры

#КонецОбласти

#Область Функциональность_работы_с_таблицами_хранилища

// Выполняет чтение таблицы VERSIONS из хранилища 1С
//
// Параметры:
//   ПутьКХранилищу - Строка - путь к хранилищу 1С
//   НачальнаяВерсия - Число - номер начальной версии хранилища
//
// Возвращаемое значение:
//   ТаблицаВерсий - ТаблицаЗначений - инициализированная таблица с колонками:
//     * Дата                - Дата   - дата версии
//     * НомерВерсии         - Число  - номер версии
// 	   * Комментарий         - Строка - комментарий автора к версии
//     * Автор               - Строка - имя автора версии в хранилище
// 	   * Тэг                 - Строка - метка версии в хранилище
// 	   * ГУИД_Автора         - Строка - уникальный идентификатор автора версии
//     * ПредставлениеАвтора - Строка - представление автора для коммита в git
//
Функция ПрочитатьТаблицуИсторииХранилища(Знач ПутьКХранилищу, Знач НачальнаяВерсия = 1) Экспорт
	
	СтандартнаяОбработка = Истина;
	
	Если НачальнаяВерсия = Неопределено Тогда
		НачальнаяВерсия = 1;	
	КонецЕсли;

	ТаблицаВерсий = НоваяТаблицаИсторииВерсий();
	
	ОбработчикПодписок.ПриПолученииТаблицыВерсий(ТаблицаВерсий, ПутьКХранилищу, НачальнаяВерсия, СтандартнаяОбработка);
	
	Если СтандартнаяОбработка Тогда
		
		Лог.Отладка("Получение таблицы версий средствами 1С.Предприятие");
		Если ХранилищеКонфигурации = Неопределено Тогда
			ХранилищеКонфигурации = ПолучитьХранилищеКонфигурации(ПутьКХранилищу);
		КонецЕсли;

		Если Не ХранилищеКонфигурации.ЧтениеХранилищаВыполнено() Тогда
		
			ХранилищеКонфигурации.ПрочитатьХранилище(НачальнаяВерсия);
		
		КонецЕсли;
		
		ТаблицаВерсийХранилища = ХранилищеКонфигурации.ПолучитьТаблицуВерсий();
		
		Для Каждого СтрокаВерсииХранилища Из ТаблицаВерсийХранилища Цикл
			
			СтрокаВерсии = ТаблицаВерсий.Добавить();
			СтрокаВерсии.НомерВерсии	= СтроковыеФункции.СтрокаВЧисло(СтрЗаменить(СтрокаВерсииХранилища.Номер, " ", ""));
			СтрокаВерсии.Автор 			= СтрокаВерсииХранилища.Автор;
			СтрокаВерсии.ГУИД_Автора 	= СтрокаВерсииХранилища.Автор;
			СтрокаВерсии.Дата 			= СтрокаВерсииХранилища.Дата;
			СтрокаВерсии.Комментарий 	= СтрокаВерсииХранилища.Комментарий;
			СтрокаВерсии.Тэг 			= ""; // теги в отчете не предоставляются
			
			СтрокаШаблонаЛога = "Добавили строку в таблицу версий:
			| Номер версии: %1
			| Автор:        %2
			| ГУИД_Автора:  %3
			| Дата:         %4
			| Комментарий:  %5
			|";
			Лог.Отладка(СтрокаШаблонаЛога, СтрокаВерсии.НомерВерсии,
										СтрокаВерсии.Автор,
										СтрокаВерсии.ГУИД_Автора,
										СтрокаВерсии.Дата,
										СтрокаВерсии.Комментарий);
			
		КонецЦикла;
		
	КонецЕсли;
	
	ТаблицаВерсий.Сортировать("НомерВерсии");
	
	ОбработчикПодписок.ПослеПолученияТаблицыВерсий(ТаблицаВерсий, ПутьКХранилищу);
	
	Возврат ТаблицаВерсий;
	
КонецФункции

// Считывает таблицу USERS пользователей хранилища
//
// Параметры:
//   ПутьКХранилищу - Строка - путь к хранилищу 1С
//   НачальнаяВерсия - Число - номер начальной версии хранилища
//
// Возвращаемое значение:
//   ТаблицаЗначений - таблица пользователей с колонками
//     * Автор               - Строка - имя автора версии в хранилище
//     * ПредставлениеАвтора - Строка - представление автора для коммита в git
// 	   * ГУИД_Автора         - Строка - уникальный идентификатор автора версии
//
Функция ПрочитатьТаблицуПользователейХранилища(Знач ПутьКХранилищу, Знач НачальнаяВерсия = 1) Экспорт
	
	СтандартнаяОбработка = Истина;
	
	ТаблицаПользователей = НоваяТаблицаПользователейХранилища();
	
	Если НачальнаяВерсия = Неопределено Тогда
		НачальнаяВерсия = 1;	
	КонецЕсли;

	ОбработчикПодписок.ПриПолученииТаблицыПользователей(ТаблицаПользователей, ПутьКХранилищу, СтандартнаяОбработка);
	
	Если СтандартнаяОбработка Тогда
		
		Если ХранилищеКонфигурации = Неопределено Тогда
			ХранилищеКонфигурации = ПолучитьХранилищеКонфигурации(ПутьКХранилищу);
		КонецЕсли;

		Если Не ХранилищеКонфигурации.ЧтениеХранилищаВыполнено() Тогда
		
			ХранилищеКонфигурации.ПрочитатьХранилище(НачальнаяВерсия);
		
		КонецЕсли;

		МассивАвторовХранилища = ХранилищеКонфигурации.ПолучитьАвторов();
		
		Для Каждого Автор Из МассивАвторовХранилища Цикл
			
			СтрокаВерсии = ТаблицаПользователей.Добавить();
			СтрокаВерсии.Автор 			= Автор;
			СтрокаВерсии.ГУИД_Автора 	= Автор;
			
		КонецЦикла;
		
	КонецЕсли;
	
	ОбработчикПодписок.ПослеПолученияТаблицыПользователей(ТаблицаПользователей, ПутьКХранилищу);
	
	Возврат ТаблицаПользователей;
	
КонецФункции

// Считывает из хранилища историю коммитов с привязкой к пользователям
//
// Параметры:
//   ПутьКХранилищу - Строка - путь к хранилищу 1С
//   ТекущаяВерсия - Число - номер версии откуда начинать чтение
//
// Возвращаемое значение:
//   ТаблицаВерсий - ТаблицаЗначений - инициализированная таблица с колонками:
//     * Дата                - Дата   - дата версии
//     * НомерВерсии         - Число  - номер версии
// 	   * Комментарий         - Строка - комментарий автора к версии
//     * Автор               - Строка - имя автора версии в хранилище
// 	   * Тэг                 - Строка - метка версии в хранилище
// 	   * ГУИД_Автора         - Строка - уникальный идентификатор автора версии
//     * ПредставлениеАвтора - Строка - представление автора для коммита в git
//
Функция ПрочитатьИзХранилищаИсториюКоммитовСАвторами(Знач ПутьКХранилищу, Знач НачальнаяВерсия = 1) Экспорт
	
	ТаблицаВерсий = ПрочитатьТаблицуИсторииХранилища(ПутьКХранилищу, НачальнаяВерсия);
	ТаблицаПользователей = ПрочитатьТаблицуПользователейХранилища(ПутьКХранилищу, НачальнаяВерсия);
	
	ДополнитьТаблицуВерсийИменамиАвторов(ТаблицаВерсий, ТаблицаПользователей);
	ТаблицаВерсий.Сортировать("НомерВерсии");
	
	Возврат ТаблицаВерсий;
	
КонецФункции

// Прописывает в таблицы пользователей и версий информацию о git auth вида user <user@email.com>
//
// Параметры:
//   ТаблицаХранилища - ТаблицаЗначений - таблица истории хранилища конфигурации
//   КаталогРабочейКопии - Строка - путь к каталогу рабочей копии git
//
Процедура ДополнитьТаблицуХранилищаИнформациейОСигнатуреПользователяВГит(Знач ТаблицаХранилища, 
																		Знач КаталогРабочейКопии) Экспорт
	
	ПутьКФайлуСопоставления = ОбъединитьПути(КаталогРабочейКопии, ИмяФайлаАвторов());
	
	ТаблицаСопоставления = ПолучитьТаблицуАвторов(ПутьКФайлуСопоставления);
	
	Для Каждого СтрокаТаблицы Из ТаблицаХранилища Цикл
		
		СтрокаПользователя = ТаблицаСопоставления.Найти(СтрокаТаблицы.Автор, "Автор");
		Если СтрокаПользователя = Неопределено Тогда
			ПредставлениеАвтора = СтрШаблон("%1 <%1@%2>", СтрокаТаблицы.Автор, Строка(ДоменПочтыДляGit()));
		Иначе
			ПредставлениеАвтора = СтрокаПользователя.ПредставлениеАвтора;
		КонецЕсли;
		
		СтрокаТаблицы.ПредставлениеАвтора = ПредставлениеАвтора;
		
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

#Область Прочая_экпортная_функцинальность

// Возвращает количество циклов ожидания лицензий
//
// Возвращаемое значение:
//   Число - количество циклов ожидания лицензии
//
Функция ПолучитьКоличествоЦикловОжиданияЛицензииПоУмолчанию() Экспорт
	Возврат КоличествоЦикловОжиданияЛицензииПоУмолчанию;
КонецФункции

// Генерирует файл соответствия пользователей хранилища 1С и git
//
// Параметры:
//   ПутьКХранилищу - Строка - путь к хранилищу 1С
//   ВыходнойФайл - Строка - путь к файлу авторов
//
Процедура СформироватьПервичныйФайлПользователейДляGit(Знач ПутьКХранилищу, Знач ВыходнойФайл) Экспорт
	
	Лог.Отладка("Формируем первичный файл авторов:
	| Путь к хранилищу: <%1>
	| Выходной файл: <%2>", ПутьКХранилищу, ВыходнойФайл);
	
	ТаблицаПользователейХранилища = ПрочитатьТаблицуПользователейХранилища(ПутьКХранилищу);
	
	ЗаписатьТаблицуПользователейВФайлАвторовGit(ТаблицаПользователейХранилища, ВыходнойФайл, ДоменПочтыДляGit());
	
КонецПроцедуры

// Получает таблицу авторов из файла
//
// Параметры:
//   ПутьКФайлуАвторов - Строка - путь к файлу авторов
//
// Возвращаемое значение:
//   ТаблицаЗначений - таблица пользователей с колонками
//     * Автор               - Строка - имя автора версии в хранилище
//     * ПредставлениеАвтора - Строка - представление автора для коммита в git
//
Функция ПолучитьТаблицуАвторов(Знач ПутьКФайлуАвторов) Экспорт
	
	СтандартнаяОбработка = Истина;

	ТаблицаАвторов = НоваяТаблицаАвторов();

	ОбработчикПодписок.ПриПолученииТаблицыАвторов(ПутьКФайлуАвторов, ТаблицаАвторов, СтандартнаяОбработка);
	
	Если СтандартнаяОбработка Тогда
		ПрочитатьФайлАвторов(ПутьКФайлуАвторов, ТаблицаАвторов);
	КонецЕсли;
	
	ОбработчикПодписок.ПослеПолученияТаблицыАвторов(ПутьКФайлуАвторов, ТаблицаАвторов);
	
	Возврат ТаблицаАвторов;

КонецФункции

Процедура ПрочитатьФайлАвторов(ПутьКФайлуАвторов, ТаблицаАвторов)
	
	Если НЕ ЗначениеЗаполнено(ПутьКФайлуАвторов) Тогда
		Возврат;
	КонецЕсли;

	Файл = Новый Файл(ПутьКФайлуАвторов);
	Если Не Файл.Существует() Тогда
		Возврат;
	КонецЕсли;

	ТекстовыйФайл = Новый ЧтениеТекста(ПутьКФайлуАвторов, "utf-8");
	ТекстФайла = ТекстовыйФайл.Прочитать();
	
	МассивСтрокФайла = СтрРазделить(ТекстФайла, Символы.ПС, Ложь);

	Для каждого СтрокаФайла Из МассивСтрокФайла Цикл

		Если СтрНачинаетсяС(СокрЛП(СтрокаФайла), "//") Тогда
			Продолжить;
		КонецЕсли;

		МассивКлючей =  СтрРазделить(СтрокаФайла, "=", Ложь);

		Если Не МассивКлючей.Количество() = 2 Тогда
			Лог.Предупреждение("Ошибка чтения файла авторов строка <%1>", СтрокаФайла);
			Продолжить;
		КонецЕсли;

		НоваяСтрока = ТаблицаАвторов.Добавить();
		НоваяСтрока.Автор = СокрЛП(МассивКлючей[0]);
		НоваяСтрока.ПредставлениеАвтора = СокрЛП(МассивКлючей[1]);

	КонецЦикла;

	ТекстовыйФайл.Закрыть();

	Если ТекстовыйФайл <> Неопределено Тогда
		ОсвободитьОбъект(ТекстовыйФайл);
	КонецЕсли;

КонецПроцедуры


// Наполняет каталог рабочей копии служебными данными
//
// Параметры:
//   КаталогРабочейКопии - Строка - путь к каталогу рабочей копии git
//   ПутьКХранилищу - Строка - путь к хранилищу 1С
//
Процедура НаполнитьКаталогРабочейКопииСлужебнымиДанными(Знач КаталогРабочейКопии, Знач ПутьКХранилищу) Экспорт
	
	КаталогИсходников = Новый Файл(КаталогРабочейКопии);
	Если Не КаталогИсходников.Существует() Тогда
		
		СоздатьКаталог(КаталогИсходников.ПолноеИмя);
		
	ИначеЕсли Не КаталогИсходников.ЭтоКаталог() Тогда
		
		ВызватьИсключение "Невозможно создать каталог " + КаталогИсходников.ПолноеИмя;
		
	КонецЕсли;
	
	СгенерироватьФайлAUTHORS(ПутьКХранилищу, КаталогИсходников.ПолноеИмя);
	СгенерироватьФайлVERSION(КаталогИсходников.ПолноеИмя);
	
КонецПроцедуры

// Производит проверку необходимости синхронизации с хранилищем
//
// Параметры:
//   КаталогРабочейКопии - Строка - Путь к каталогу рабочей копии git
//   ПутьКХранилищу - Строка - Путь к хранилищу 1С
//
// Возвращаемое значение:
//   Булево - признак необходимости синхронизации
//
Функция ТребуетсяСинхронизироватьХранилищеСГит(Знач КаталогРабочейКопии, Знач ПутьКХранилищу) Экспорт
	
	ТаблицаВерсий = ПрочитатьТаблицуИсторииХранилища(ПутьКХранилищу);
	ТекущаяВерсия = НомерСинхронизированнойВерсии(КаталогРабочейКопии);
	МаксимальнаяВерсияДляРазбора = ОпределитьМаксимальнуюВерсиюВХранилище(ТаблицаВерсий);
	
	Лог.Информация("Номер синхронизированной версии: " + ТекущаяВерсия);
	Лог.Информация("Номер последней версии в хранилище: " + МаксимальнаяВерсияДляРазбора);
	
	Возврат ТекущаяВерсия < МаксимальнаяВерсияДляРазбора;
	
КонецФункции

// Возвращает имя файла авторов
//
// Возвращаемое значение:
//   Строка - Имя файла авторов
//
Функция ИмяФайлаАвторов() Экспорт
	Возврат "AUTHORS";
КонецФункции

// Возвращачет имя файла версий
//
// Возвращаемое значение:
//   Строка - Имя файла версий
//
Функция ИмяФайлаВерсииХранилища() Экспорт
	Возврат "VERSION";
КонецФункции

// Производит запись файла версий
//
// Параметры:
//   КаталогФайлаВерсий - Строка - путь к каталогу для записи файла
//   Версия - Строка, Число - номер записываемой версии
//
Процедура ЗаписатьФайлВерсийГит(Знач КаталогФайлаВерсий, Знач Версия = "0") Экспорт
	
	ПутьКФайлуВерсий = ОбъединитьПути(КаталогФайлаВерсий, ИмяФайлаВерсииХранилища());
	Лог.Отладка("ПутьКФайлуВерсий = <%1>", ПутьКФайлуВерсий);
	Попытка
		Запись = Новый ЗаписьТекста(ПутьКФайлуВерсий, "utf-8");
		Запись.ЗаписатьСтроку("<?xml version=""1.0"" encoding=""UTF-8""?>");
		Запись.ЗаписатьСтроку("<VERSION>" + Версия + "</VERSION>");
		Запись.Закрыть();
	Исключение
		Если Запись <> Неопределено Тогда
			ОсвободитьОбъект(Запись);
		КонецЕсли;
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

#КонецОбласти

#Область Вспомогательные_процедуры_и_функции

Функция НоваяТаблицаИсторииВерсий()
	
	Таблица = Новый ТаблицаЗначений;
	Таблица.Колонки.Добавить("НомерВерсии");
	Таблица.Колонки.Добавить("ГУИД_Автора");
	Таблица.Колонки.Добавить("Автор");
	Таблица.Колонки.Добавить("Тэг");
	Таблица.Колонки.Добавить("Дата");
	Таблица.Колонки.Добавить("Комментарий");
	Таблица.Колонки.Добавить("ПредставлениеАвтора");
	
	Возврат Таблица;
	
КонецФункции

Процедура ПроверитьПараметрыДоступаКХранилищу()
	
	Если АвторизацияВХранилище.ПользовательХранилища = Неопределено
		ИЛИ ПустаяСтрока(АвторизацияВХранилище.ПользовательХранилища) Тогда
		
		ВызватьИсключение "Не задан пользователь хранилища конфигурации.";
		
	КонецЕсли;
	
	Если АвторизацияВХранилище.ПарольХранилища = Неопределено Тогда
		
		АвторизацияВХранилище.ПарольХранилища = "";
		
	КонецЕсли;
	
КонецПроцедуры

Функция МассивИсключаемыхОшибок()

	Массив = Новый Массив;
	Массив.Добавить("Конфигурация содержит объекты метаданных, длина имен которых превышает 80 символов!");

	Возврат Массив;
КонецФункции

Функция ЭтоПропускаемаяОшибка(Знач ОписаниеОшибки)

	МассивИсключаемыхОшибок = МассивИсключаемыхОшибок();

	Для Каждого ИсключаемаяОшибка Из МассивИсключаемыхОшибок Цикл

		Если СтрНайти(ОписаниеОшибки, ИсключаемаяОшибка) > 0 Тогда 
			Возврат Истина; 
		КонецЕсли;

	КонецЦикла;
	Возврат Ложь;
КонецФункции

Процедура СоздатьРасширениеВБазе(УправлениеКонфигуратором)
	
	Параметры = УправлениеКонфигуратором.ПолучитьПараметрыЗапуска();
	ЗагрузчикЗапакованныхФайловGitsync = Новый ЗагрузчикЗапакованныхФайловGitsync;
	ПутьКШаблонуРасширения = ЗагрузчикЗапакованныхФайловGitsync.ПолучитьПутьКФайлу("tempExtension.cfe");
	Параметры.Добавить(СтрШаблон("/LoadCfg ""%1""", ПутьКШаблонуРасширения));
	Параметры.Добавить(СтрШаблон("-Extension %1", ИмяРасширения));
	УправлениеКонфигуратором.ВыполнитьКоманду(Параметры);

КонецПроцедуры


Функция ПолучитьХранилищеКонфигурации(Знач ПутьКХранилищу)
	
	МенеджерХранилищаКонфигурации = Новый МенеджерХранилищаКонфигурации;
	НовыйУправлениеКонфигуратором = ПолучитьРабочийКонфигуратор();
	НовыйУправлениеКонфигуратором.УстановитьКодЯзыка("RU"); // TODO: Костыль выгрузки истории хранилища с другими языками выгружает только в RU
	МенеджерХранилищаКонфигурации.УстановитьУправлениеКонфигуратором(НовыйУправлениеКонфигуратором);

	Если ЗначениеЗаполнено(ИмяРасширения) Тогда
		Лог.Отладка("Устанавливаю имя расширения <%1> для синхронизации", ИмяРасширения);
		
		СоздатьРасширениеВБазе(НовыйУправлениеКонфигуратором);
		МенеджерХранилищаКонфигурации.УстановитьРасширениеХранилища(ИмяРасширения);

	КонецЕсли;

	Логирование.ПолучитьЛог("oscript.lib.v8storage").УстановитьУровень(Лог.Уровень());
	ПроверитьПараметрыДоступаКХранилищу();
	МенеджерХранилищаКонфигурации.УстановитьПараметрыАвторизации(АвторизацияВХранилище.ПользовательХранилища, АвторизацияВХранилище.ПарольХранилища);
	МенеджерХранилищаКонфигурации.УстановитьПутьКХранилищу(ПутьКХранилищу);
	
	Возврат МенеджерХранилищаКонфигурации;
	
КонецФункции

Функция НоваяТаблицаПользователейХранилища()
	
	Таблица = Новый ТаблицаЗначений;
	Таблица.Колонки.Добавить("Автор");
	Таблица.Колонки.Добавить("ГУИД_Автора");
	Таблица.Колонки.Добавить("ПредставлениеАвтора");
	
	Возврат Таблица;
	
КонецФункции

Функция НоваяТаблицаАвторов()
	
	Таблица = Новый ТаблицаЗначений;
	Таблица.Колонки.Добавить("Автор");
	Таблица.Колонки.Добавить("ПредставлениеАвтора");
	
	Возврат Таблица;
	
КонецФункции

Функция ПодготовитьФайлКоммита(Знач Комментарий)
	
	ИмяФайлаКомментария = ВременныеФайлы.СоздатьФайл("txt");
	ФайлКомментария = Новый ЗаписьТекста(ИмяФайлаКомментария, КодировкаТекста.UTF8NoBOM);
	ФайлКомментария.Записать(?(ПустаяСтрока(Комментарий), ".", Комментарий));
	ФайлКомментария.Закрыть();
	Лог.Отладка(СтрШаблон("Текст коммита: %1", Комментарий));
	
	Возврат ИмяФайлаКомментария;
	
КонецФункции

Процедура ДополнитьТаблицуВерсийИменамиАвторов(Знач ТаблицаВерсий, Знач ТаблицаПользователей)
	
	Для Каждого Строка Из ТаблицаВерсий Цикл
		СтрокаПользователя = ТаблицаПользователей.Найти(Строка.ГУИД_Автора, "ГУИД_Автора");
		Если СтрокаПользователя = Неопределено Тогда
			Сообщение = "Не удалось найти автора коммита из хранилища 1С по номеру версии <%1>,
			| комментарий <%2>, ГУИД-у <%3> - ПолучитьТаблицуВерсийИзФайлаХранилища1С";
			Лог.Ошибка(СтрШаблон(Сообщение, Строка.НомерВерсии, Строка.Комментарий, Строка.ГУИД_Автора));
		Иначе
			Строка.Автор = СтрокаПользователя.Автор;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

Процедура ЗаписатьТаблицуПользователейВФайлАвторовGit(Знач ТаблицаПользователейХранилища,
	Знач ВыходнойФайл,
	Знач ДоменПочтыДляGit)
	
	ЗаписьФайла = Новый ЗаписьТекста(ВыходнойФайл, "utf-8");
	Попытка
		ШаблонЗаписи = "%1=%1 <%1@%2>";
		Для Каждого Запись Из ТаблицаПользователейХранилища Цикл
			СтрокаДляЗаписи = СтрШаблон(ШаблонЗаписи, Запись.Автор, ДоменПочтыДляGit);
			ЗаписьФайла.ЗаписатьСтроку(СтрокаДляЗаписи);
		КонецЦикла;
		
		ЗаписьФайла.Закрыть();
	Исключение
		ОсвободитьОбъект(ЗаписьФайла);
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

Функция НомерСинхронизированнойВерсии(Знач КаталогВыгрузки)
	
	ПутьФайлаВерсий = ОбъединитьПути(КаталогВыгрузки, ИмяФайлаВерсииХранилища());
	
	ТекущаяВерсия = ПрочитатьФайлВерсийГит(ПутьФайлаВерсий);
	Если ТекущаяВерсия <> Неопределено Тогда
		Попытка
			ТекущаяВерсия = Число(ТекущаяВерсия);
		Исключение
			ТекущаяВерсия = 0;
		КонецПопытки;
	Иначе
		ТекущаяВерсия = 0;
	КонецЕсли;
	
	Возврат ТекущаяВерсия;
	
КонецФункции

Функция ОпределитьМаксимальнуюВерсиюВХранилище(Знач ТаблицаИсторииХранилища)
	
	Если ТаблицаИсторииХранилища.Количество() = 0 Тогда
		Возврат 0;
	КонецЕсли;
	
	МаксимальнаяВерсия = Число(ТаблицаИсторииХранилища[0].НомерВерсии);
	Для Сч = 1 По ТаблицаИсторииХранилища.Количество() - 1 Цикл
		ЧислоВерсии = Число(ТаблицаИсторииХранилища[Сч].НомерВерсии);
		Если ЧислоВерсии > МаксимальнаяВерсия Тогда
			МаксимальнаяВерсия = ЧислоВерсии;
		КонецЕсли;
	КонецЦикла;
	
	Возврат МаксимальнаяВерсия;
	
КонецФункции

Функция ПрочитатьФайлВерсийГит(Знач ПутьКФайлуВерсий)
	
	Перем Версия;
	
	Если Не Новый Файл(ПутьКФайлуВерсий).Существует() Тогда
		ВызватьИсключение СтрШаблон("Файл с версией ГИТ <%1> не существует", ПутьКФайлуВерсий);
	КонецЕсли;
	
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.ОткрытьФайл(ПутьКФайлуВерсий);
	
	Пока ЧтениеXML.Прочитать() Цикл
		Если ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента И ЧтениеXML.Имя = "VERSION" Тогда
			
			Если Не ЧтениеXML.Прочитать() Тогда
				ВызватьИсключение "Чтение файла версий, у элемента Version нет текста";
			КонецЕсли;
			
			Если Не ЧтениеXML.ТипУзла = ТипУзлаXML.Текст Тогда
				ВызватьИсключение "Чтение файла версий, у элемента Version нет текста";
			КонецЕсли;
			
			Версия = ЧтениеXML.Значение;
			Лог.Отладка("Предыдущая версия из хранилища 1С: <%1>", Версия);
			
			Прервать;
		КонецЕсли;
		
	КонецЦикла;
	
	ЧтениеXML.Закрыть();
	
	Возврат Версия;
	
КонецФункции

Процедура СгенерироватьФайлAUTHORS(Знач ПутьХранилища, Знач КаталогИсходников)
	
	ФайлАвторов = Новый Файл(ОбъединитьПути(КаталогИсходников, "AUTHORS"));
	Если ФайлАвторов.Существует() Тогда
		
		Лог.Информация("Файл <%1> уже существует. Пропускаем генерацию файла AUTHORS", ФайлАвторов.ПолноеИмя);
		Возврат;
		
	КонецЕсли;
	
	Попытка
		
		Лог.Отладка("Формирую файл AUTHORS в каталоге <%1>", КаталогИсходников);
		СформироватьПервичныйФайлПользователейДляGit(ПутьХранилища, ФайлАвторов.ПолноеИмя);
		Лог.Отладка("Файл сгенерирован");
		
	Исключение
		
		Лог.Ошибка("Не удалось сформировать файл авторов");
		ВызватьИсключение;
		
	КонецПопытки;
	
КонецПроцедуры

Процедура СгенерироватьФайлVERSION(Знач КаталогИсходников)
	
	ФайлВерсий = Новый Файл(ОбъединитьПути(КаталогИсходников, "VERSION"));
	Если ФайлВерсий.Существует() Тогда
		
		Лог.Информация("Файл <%1> уже существует. Пропускаем генерацию файла VERSION", ФайлВерсий.ПолноеИмя);
		Возврат;
		
	КонецЕсли;
	
	ЗаписатьФайлВерсийГит(ФайлВерсий.Путь);
	
КонецПроцедуры

// Удаляет временные файлы при необходимости
// Если передана пустая строка, то удаляются все зарегистрированные временные файлы
//
// Параметры:
//   ПутьКФайлу - Строка - полный путь файла или пустая строка
//
Процедура УдалитьВременныеФайлыПриНеобходимости(Знач ПутьКФайлу = "")
	
	Если НЕ УдалятьВременныеФайлы Тогда
		Возврат;
	КонецЕсли;
	
	Если ПутьКФайлу = "" Тогда
		ВременныеФайлы.Удалить();
	Иначе
		ВременныеФайлы.УдалитьФайл(ПутьКФайлу);
	КонецЕсли;
	
КонецПроцедуры

Процедура УстановитьОбработчикПодписок(НовыйИндексПодписчиков)
	
	ОбработчикПодписок.УстановитьПодписчиков(НовыйИндексПодписчиков);
	ОбработчикПодписок.ПриАктивизации(ЭтотОбъект);
	
КонецПроцедуры

Функция ИмяЛога()
	
	Возврат "oscript.lib.gitsync";
	
КонецФункции

Функция ДатаPOSIX(Знач Дата)
	
	Возврат "" + Год(Дата) + "-" + ФорматДвузначноеЧисло(Месяц(Дата)) + "-" + ФорматДвузначноеЧисло(День(Дата)) + " "
	+ ФорматДвузначноеЧисло(Час(Дата)) + ":" + ФорматДвузначноеЧисло(Минута(Дата))
	+ ":" + ФорматДвузначноеЧисло(Секунда(Дата));
	
КонецФункции

Процедура ЗавершитьПроцесс_TGitCache_exe()
	
	Если Не ЭтоWindows Тогда
		Возврат;
	КонецЕсли;
	
	ИмяПроцессаКешаГит = "TGitCache.exe";
	
	МассивПроцессов = НайтиПроцессыПоИмени(ИмяПроцессаКешаГит);
	
	Если МассивПроцессов.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	КомандаTaskKill = Новый Команда;
	КомандаTaskKill.УстановитьКоманду("taskkill");
	КомандаTaskKill.ДобавитьПараметр("/im");	
	КомандаTaskKill.ДобавитьПараметр(ИмяПроцессаКешаГит);	
	КомандаTaskKill.ДобавитьПараметр("/T");	
	КомандаTaskKill.ДобавитьПараметр("/F");	
	КомандаTaskKill.ДобавитьЛогВыводаКоманды(ИмяЛога());
	
	КодВозврата = КомандаTaskKill.Исполнить();
	
	Если КодВозврата <> 0  Тогда
		КомандаTaskKill.УстановитьКоманду("%windir%/Sysnative/taskkill");
		КодВозврата = КомандаTaskKill.Исполнить();
	КонецЕсли;
	
	Если КодВозврата <> 0 Тогда
		Лог.КритичнаяОшибка("Не удалось завершить процесс <%>", ИмяПроцессаКешаГит);
	КонецЕсли;
	
КонецПроцедуры

Процедура ПоказатьКонтекстВРежимеОтладки()
	Лог.Отладка("СтрокаСоединения <%1>", КонтекстВыполнения.СтрокаСоединения);
	Лог.Отладка("Пользователь <%1>", КонтекстВыполнения.Пользователь);
	Лог.Отладка(?(ПустаяСтрока(КонтекстВыполнения.Пароль), "Пароль не задан", СтрШаблон("Задан пароль <%1>", КонтекстВыполнения.Пароль)));
КонецПроцедуры

Функция ФорматДвузначноеЧисло(ЗначениеЧисло)
	ЧислоСтрокой = Строка(ЗначениеЧисло);
	Если СтрДлина(ЧислоСтрокой) < 2 Тогда
		ЧислоСтрокой = "0" + ЧислоСтрокой;
	КонецЕсли;
	
	Возврат ЧислоСтрокой;
КонецФункции

Функция ДоменПочтыДляGit()
	Возврат ?(ДоменПочтыДляGitПоУмолчанию = Неопределено, "localhost", ДоменПочтыДляGitПоУмолчанию);
КонецФункции

Процедура ПриСозданииОбъекта()
	
	ОбработчикПодписок = Новый МенеджерПодписок(Новый Соответствие);
	
	Лог = Логирование.ПолучитьЛог(ИмяЛога());
	
	УдалятьВременныеФайлы = Ложь;
	МинимальнаяРазницаМеждуКоммитамиНовогоХранилища = 10;
	АвторизацияВХранилище = Новый Структура("ПользовательХранилища, ПарольХранилища");
	
	КоличествоЦикловОжиданияЛицензииПоУмолчанию = 3;
	
	СистемнаяИнформация = Новый СистемнаяИнформация;
	ЭтоWindows = Найти(НРег(СистемнаяИнформация.ВерсияОС), "windows") > 0;
	
	ТекущаяВерсияПлатформы = "8.3";

	КонтекстВыполнения = Новый Структура("СтрокаСоединения, Пользователь, Пароль", "", "", "");
	
КонецПроцедуры

#КонецОбласти
